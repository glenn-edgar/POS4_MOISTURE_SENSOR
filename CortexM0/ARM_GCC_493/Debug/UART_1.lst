ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UART_1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	UART_1_initVar
  18              		.bss
  19              		.type	UART_1_initVar, %object
  20              		.size	UART_1_initVar, 1
  21              	UART_1_initVar:
  22 0000 00       		.space	1
  23              		.section	.text.UART_1_Start,"ax",%progbits
  24              		.align	2
  25              		.global	UART_1_Start
  26              		.code	16
  27              		.thumb_func
  28              		.type	UART_1_Start, %function
  29              	UART_1_Start:
  30              	.LFB1:
  31              		.file 1 "Generated_Source\\PSoC4\\UART_1.c"
   1:Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
   2:Generated_Source\PSoC4/UART_1.c **** * File Name: UART_1.c
   3:Generated_Source\PSoC4/UART_1.c **** * Version 2.50
   4:Generated_Source\PSoC4/UART_1.c **** *
   5:Generated_Source\PSoC4/UART_1.c **** * Description:
   6:Generated_Source\PSoC4/UART_1.c **** *  This file provides all API functionality of the UART component
   7:Generated_Source\PSoC4/UART_1.c **** *
   8:Generated_Source\PSoC4/UART_1.c **** * Note:
   9:Generated_Source\PSoC4/UART_1.c **** *
  10:Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  11:Generated_Source\PSoC4/UART_1.c **** * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12:Generated_Source\PSoC4/UART_1.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:Generated_Source\PSoC4/UART_1.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:Generated_Source\PSoC4/UART_1.c **** * the software package with which this file was provided.
  15:Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  16:Generated_Source\PSoC4/UART_1.c **** 
  17:Generated_Source\PSoC4/UART_1.c **** #include "UART_1.h"
  18:Generated_Source\PSoC4/UART_1.c **** #if (UART_1_INTERNAL_CLOCK_USED)
  19:Generated_Source\PSoC4/UART_1.c ****     #include "UART_1_IntClock.h"
  20:Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_INTERNAL_CLOCK_USED */
  21:Generated_Source\PSoC4/UART_1.c **** 
  22:Generated_Source\PSoC4/UART_1.c **** 
  23:Generated_Source\PSoC4/UART_1.c **** /***************************************
  24:Generated_Source\PSoC4/UART_1.c **** * Global data allocation
  25:Generated_Source\PSoC4/UART_1.c **** ***************************************/
  26:Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 2


  27:Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_initVar = 0u;
  28:Generated_Source\PSoC4/UART_1.c **** 
  29:Generated_Source\PSoC4/UART_1.c **** #if (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED)
  30:Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBuffer[UART_1_TX_BUFFER_SIZE];
  31:Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBufferRead = 0u;
  32:Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_txBufferWrite = 0u;
  33:Generated_Source\PSoC4/UART_1.c **** #endif /* (UART_1_TX_INTERRUPT_ENABLED && UART_1_TX_ENABLED) */
  34:Generated_Source\PSoC4/UART_1.c **** 
  35:Generated_Source\PSoC4/UART_1.c **** #if (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED))
  36:Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_errorStatus = 0u;
  37:Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBuffer[UART_1_RX_BUFFER_SIZE];
  38:Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferRead  = 0u;
  39:Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferWrite = 0u;
  40:Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferLoopDetect = 0u;
  41:Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferOverflow   = 0u;
  42:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RXHW_ADDRESS_ENABLED)
  43:Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressMode = UART_1_RX_ADDRESS_MODE;
  44:Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressDetected = 0u;
  45:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
  46:Generated_Source\PSoC4/UART_1.c **** #endif /* (UART_1_RX_INTERRUPT_ENABLED && (UART_1_RX_ENABLED || UART_1_HD_ENABLED)) */
  47:Generated_Source\PSoC4/UART_1.c **** 
  48:Generated_Source\PSoC4/UART_1.c **** 
  49:Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  50:Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Start
  51:Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  52:Generated_Source\PSoC4/UART_1.c **** *
  53:Generated_Source\PSoC4/UART_1.c **** * Summary:
  54:Generated_Source\PSoC4/UART_1.c **** *  This is the preferred method to begin component operation.
  55:Generated_Source\PSoC4/UART_1.c **** *  UART_1_Start() sets the initVar variable, calls the
  56:Generated_Source\PSoC4/UART_1.c **** *  UART_1_Init() function, and then calls the
  57:Generated_Source\PSoC4/UART_1.c **** *  UART_1_Enable() function.
  58:Generated_Source\PSoC4/UART_1.c **** *
  59:Generated_Source\PSoC4/UART_1.c **** * Parameters:
  60:Generated_Source\PSoC4/UART_1.c **** *  None.
  61:Generated_Source\PSoC4/UART_1.c **** *
  62:Generated_Source\PSoC4/UART_1.c **** * Return:
  63:Generated_Source\PSoC4/UART_1.c **** *  None.
  64:Generated_Source\PSoC4/UART_1.c **** *
  65:Generated_Source\PSoC4/UART_1.c **** * Global variables:
  66:Generated_Source\PSoC4/UART_1.c **** *  The UART_1_intiVar variable is used to indicate initial
  67:Generated_Source\PSoC4/UART_1.c **** *  configuration of this component. The variable is initialized to zero (0u)
  68:Generated_Source\PSoC4/UART_1.c **** *  and set to one (1u) the first time UART_1_Start() is called. This
  69:Generated_Source\PSoC4/UART_1.c **** *  allows for component initialization without re-initialization in all
  70:Generated_Source\PSoC4/UART_1.c **** *  subsequent calls to the UART_1_Start() routine.
  71:Generated_Source\PSoC4/UART_1.c **** *
  72:Generated_Source\PSoC4/UART_1.c **** * Reentrant:
  73:Generated_Source\PSoC4/UART_1.c **** *  No.
  74:Generated_Source\PSoC4/UART_1.c **** *
  75:Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  76:Generated_Source\PSoC4/UART_1.c **** void UART_1_Start(void) 
  77:Generated_Source\PSoC4/UART_1.c **** {
  32              		.loc 1 77 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 3


  38 0002 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
  78:Generated_Source\PSoC4/UART_1.c ****     /* If not initialized then initialize all required hardware and software */
  79:Generated_Source\PSoC4/UART_1.c ****     if(UART_1_initVar == 0u)
  40              		.loc 1 79 0
  41 0004 064B     		ldr	r3, .L3
  42 0006 1B78     		ldrb	r3, [r3]
  43 0008 002B     		cmp	r3, #0
  44 000a 04D1     		bne	.L2
  80:Generated_Source\PSoC4/UART_1.c ****     {
  81:Generated_Source\PSoC4/UART_1.c ****         UART_1_Init();
  45              		.loc 1 81 0
  46 000c FFF7FEFF 		bl	UART_1_Init
  82:Generated_Source\PSoC4/UART_1.c ****         UART_1_initVar = 1u;
  47              		.loc 1 82 0
  48 0010 034B     		ldr	r3, .L3
  49 0012 0122     		mov	r2, #1
  50 0014 1A70     		strb	r2, [r3]
  51              	.L2:
  83:Generated_Source\PSoC4/UART_1.c ****     }
  84:Generated_Source\PSoC4/UART_1.c **** 
  85:Generated_Source\PSoC4/UART_1.c ****     UART_1_Enable();
  52              		.loc 1 85 0
  53 0016 FFF7FEFF 		bl	UART_1_Enable
  86:Generated_Source\PSoC4/UART_1.c **** }
  54              		.loc 1 86 0
  55 001a BD46     		mov	sp, r7
  56              		@ sp needed
  57 001c 80BD     		pop	{r7, pc}
  58              	.L4:
  59 001e C046     		.align	2
  60              	.L3:
  61 0020 00000000 		.word	UART_1_initVar
  62              		.cfi_endproc
  63              	.LFE1:
  64              		.size	UART_1_Start, .-UART_1_Start
  65              		.section	.text.UART_1_Init,"ax",%progbits
  66              		.align	2
  67              		.global	UART_1_Init
  68              		.code	16
  69              		.thumb_func
  70              		.type	UART_1_Init, %function
  71              	UART_1_Init:
  72              	.LFB2:
  87:Generated_Source\PSoC4/UART_1.c **** 
  88:Generated_Source\PSoC4/UART_1.c **** 
  89:Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  90:Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Init
  91:Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  92:Generated_Source\PSoC4/UART_1.c **** *
  93:Generated_Source\PSoC4/UART_1.c **** * Summary:
  94:Generated_Source\PSoC4/UART_1.c **** *  Initializes or restores the component according to the customizer Configure
  95:Generated_Source\PSoC4/UART_1.c **** *  dialog settings. It is not necessary to call UART_1_Init() because
  96:Generated_Source\PSoC4/UART_1.c **** *  the UART_1_Start() API calls this function and is the preferred
  97:Generated_Source\PSoC4/UART_1.c **** *  method to begin component operation.
  98:Generated_Source\PSoC4/UART_1.c **** *
  99:Generated_Source\PSoC4/UART_1.c **** * Parameters:
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 4


 100:Generated_Source\PSoC4/UART_1.c **** *  None.
 101:Generated_Source\PSoC4/UART_1.c **** *
 102:Generated_Source\PSoC4/UART_1.c **** * Return:
 103:Generated_Source\PSoC4/UART_1.c **** *  None.
 104:Generated_Source\PSoC4/UART_1.c **** *
 105:Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 106:Generated_Source\PSoC4/UART_1.c **** void UART_1_Init(void) 
 107:Generated_Source\PSoC4/UART_1.c **** {
  73              		.loc 1 107 0
  74              		.cfi_startproc
  75 0000 80B5     		push	{r7, lr}
  76              		.cfi_def_cfa_offset 8
  77              		.cfi_offset 7, -8
  78              		.cfi_offset 14, -4
  79 0002 00AF     		add	r7, sp, #0
  80              		.cfi_def_cfa_register 7
 108:Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 109:Generated_Source\PSoC4/UART_1.c **** 
 110:Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 111:Generated_Source\PSoC4/UART_1.c ****             /* Set RX interrupt vector and priority */
 112:Generated_Source\PSoC4/UART_1.c ****             (void) CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
 113:Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
 114:Generated_Source\PSoC4/UART_1.c ****             UART_1_errorStatus = 0u;
 115:Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 116:Generated_Source\PSoC4/UART_1.c **** 
 117:Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RXHW_ADDRESS_ENABLED)
 118:Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddressMode(UART_1_RX_ADDRESS_MODE);
 119:Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress1(UART_1_RX_HW_ADDRESS1);
 120:Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress2(UART_1_RX_HW_ADDRESS2);
 121:Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 122:Generated_Source\PSoC4/UART_1.c **** 
 123:Generated_Source\PSoC4/UART_1.c ****         /* Init Count7 period */
 124:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
  81              		.loc 1 124 0
  82 0004 084B     		ldr	r3, .L6
  83 0006 7222     		mov	r2, #114
  84 0008 1A70     		strb	r2, [r3]
 125:Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial RX interrupt mask */
 126:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
  85              		.loc 1 126 0
  86 000a 084B     		ldr	r3, .L6+4
  87 000c 2022     		mov	r2, #32
  88 000e 1A70     		strb	r2, [r3]
 127:Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 128:Generated_Source\PSoC4/UART_1.c **** 
 129:Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 130:Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 131:Generated_Source\PSoC4/UART_1.c ****             /* Set TX interrupt vector and priority */
 132:Generated_Source\PSoC4/UART_1.c ****             (void) CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
 133:Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
 134:Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 135:Generated_Source\PSoC4/UART_1.c **** 
 136:Generated_Source\PSoC4/UART_1.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 137:Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TXCLKGEN_DP)
 138:Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
  89              		.loc 1 138 0
  90 0010 074B     		ldr	r3, .L6+8
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 5


  91 0012 0622     		mov	r2, #6
  92 0014 1A70     		strb	r2, [r3]
 139:Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKTX_COMPLETE_REG = ((UART_1_NUMBER_OF_DATA_BITS +
  93              		.loc 1 139 0
  94 0016 074B     		ldr	r3, .L6+12
  95 0018 4722     		mov	r2, #71
  96 001a 1A70     		strb	r2, [r3]
 140:Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT) - 1u;
 141:Generated_Source\PSoC4/UART_1.c ****         #else
 142:Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 143:Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
 144:Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 145:Generated_Source\PSoC4/UART_1.c **** 
 146:Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial TX interrupt mask */
 147:Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 148:Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
 149:Generated_Source\PSoC4/UART_1.c ****         #else
 150:Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
  97              		.loc 1 150 0
  98 001c 064B     		ldr	r3, .L6+16
  99 001e 0A22     		mov	r2, #10
 100 0020 1A70     		strb	r2, [r3]
 151:Generated_Source\PSoC4/UART_1.c ****         #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 152:Generated_Source\PSoC4/UART_1.c **** 
 153:Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 154:Generated_Source\PSoC4/UART_1.c **** 
 155:Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 156:Generated_Source\PSoC4/UART_1.c ****         UART_1_WriteControlRegister( \
 157:Generated_Source\PSoC4/UART_1.c ****             (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
 158:Generated_Source\PSoC4/UART_1.c ****             (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
 159:Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_PARITY_TYPE_SW */
 160:Generated_Source\PSoC4/UART_1.c **** }
 101              		.loc 1 160 0
 102 0022 BD46     		mov	sp, r7
 103              		@ sp needed
 104 0024 80BD     		pop	{r7, pc}
 105              	.L7:
 106 0026 C046     		.align	2
 107              	.L6:
 108 0028 80000F40 		.word	1074724992
 109 002c 81000F40 		.word	1074724993
 110 0030 23000F40 		.word	1074724899
 111 0034 33000F40 		.word	1074724915
 112 0038 82000F40 		.word	1074724994
 113              		.cfi_endproc
 114              	.LFE2:
 115              		.size	UART_1_Init, .-UART_1_Init
 116              		.section	.text.UART_1_Enable,"ax",%progbits
 117              		.align	2
 118              		.global	UART_1_Enable
 119              		.code	16
 120              		.thumb_func
 121              		.type	UART_1_Enable, %function
 122              	UART_1_Enable:
 123              	.LFB3:
 161:Generated_Source\PSoC4/UART_1.c **** 
 162:Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 6


 163:Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 164:Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Enable
 165:Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 166:Generated_Source\PSoC4/UART_1.c **** *
 167:Generated_Source\PSoC4/UART_1.c **** * Summary:
 168:Generated_Source\PSoC4/UART_1.c **** *  Activates the hardware and begins component operation. It is not necessary
 169:Generated_Source\PSoC4/UART_1.c **** *  to call UART_1_Enable() because the UART_1_Start() API
 170:Generated_Source\PSoC4/UART_1.c **** *  calls this function, which is the preferred method to begin component
 171:Generated_Source\PSoC4/UART_1.c **** *  operation.
 172:Generated_Source\PSoC4/UART_1.c **** 
 173:Generated_Source\PSoC4/UART_1.c **** * Parameters:
 174:Generated_Source\PSoC4/UART_1.c **** *  None.
 175:Generated_Source\PSoC4/UART_1.c **** *
 176:Generated_Source\PSoC4/UART_1.c **** * Return:
 177:Generated_Source\PSoC4/UART_1.c **** *  None.
 178:Generated_Source\PSoC4/UART_1.c **** *
 179:Generated_Source\PSoC4/UART_1.c **** * Global Variables:
 180:Generated_Source\PSoC4/UART_1.c **** *  UART_1_rxAddressDetected - set to initial state (0).
 181:Generated_Source\PSoC4/UART_1.c **** *
 182:Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 183:Generated_Source\PSoC4/UART_1.c **** void UART_1_Enable(void) 
 184:Generated_Source\PSoC4/UART_1.c **** {
 124              		.loc 1 184 0
 125              		.cfi_startproc
 126 0000 90B5     		push	{r4, r7, lr}
 127              		.cfi_def_cfa_offset 12
 128              		.cfi_offset 4, -12
 129              		.cfi_offset 7, -8
 130              		.cfi_offset 14, -4
 131 0002 83B0     		sub	sp, sp, #12
 132              		.cfi_def_cfa_offset 24
 133 0004 00AF     		add	r7, sp, #0
 134              		.cfi_def_cfa_register 7
 185:Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 186:Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 135              		.loc 1 186 0
 136 0006 FC1D     		add	r4, r7, #7
 137 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 138 000c 031C     		mov	r3, r0
 139 000e 2370     		strb	r3, [r4]
 187:Generated_Source\PSoC4/UART_1.c **** 
 188:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 189:Generated_Source\PSoC4/UART_1.c ****         /* RX Counter (Count7) Enable */
 190:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 140              		.loc 1 190 0
 141 0010 114A     		ldr	r2, .L9
 142 0012 114B     		ldr	r3, .L9
 143 0014 1B78     		ldrb	r3, [r3]
 144 0016 DBB2     		uxtb	r3, r3
 145 0018 2021     		mov	r1, #32
 146 001a 0B43     		orr	r3, r1
 147 001c DBB2     		uxtb	r3, r3
 148 001e 1370     		strb	r3, [r2]
 191:Generated_Source\PSoC4/UART_1.c **** 
 192:Generated_Source\PSoC4/UART_1.c ****         /* Enable the RX Interrupt */
 193:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 149              		.loc 1 193 0
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 7


 150 0020 0E4A     		ldr	r2, .L9+4
 151 0022 0E4B     		ldr	r3, .L9+4
 152 0024 1B78     		ldrb	r3, [r3]
 153 0026 DBB2     		uxtb	r3, r3
 154 0028 1021     		mov	r1, #16
 155 002a 0B43     		orr	r3, r1
 156 002c DBB2     		uxtb	r3, r3
 157 002e 1370     		strb	r3, [r2]
 194:Generated_Source\PSoC4/UART_1.c **** 
 195:Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 196:Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableRxInt();
 197:Generated_Source\PSoC4/UART_1.c **** 
 198:Generated_Source\PSoC4/UART_1.c ****             #if (UART_1_RXHW_ADDRESS_ENABLED)
 199:Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxAddressDetected = 0u;
 200:Generated_Source\PSoC4/UART_1.c ****             #endif /* (UART_1_RXHW_ADDRESS_ENABLED) */
 201:Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 202:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 203:Generated_Source\PSoC4/UART_1.c **** 
 204:Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 205:Generated_Source\PSoC4/UART_1.c ****         /* TX Counter (DP/Count7) Enable */
 206:Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 207:Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 208:Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 209:Generated_Source\PSoC4/UART_1.c **** 
 210:Generated_Source\PSoC4/UART_1.c ****         /* Enable the TX Interrupt */
 211:Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 158              		.loc 1 211 0
 159 0030 0B4A     		ldr	r2, .L9+8
 160 0032 0B4B     		ldr	r3, .L9+8
 161 0034 1B78     		ldrb	r3, [r3]
 162 0036 DBB2     		uxtb	r3, r3
 163 0038 1021     		mov	r1, #16
 164 003a 0B43     		orr	r3, r1
 165 003c DBB2     		uxtb	r3, r3
 166 003e 1370     		strb	r3, [r2]
 212:Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
 213:Generated_Source\PSoC4/UART_1.c ****             UART_1_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
 214:Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
 215:Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 216:Generated_Source\PSoC4/UART_1.c ****      #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 217:Generated_Source\PSoC4/UART_1.c **** 
 218:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_INTERNAL_CLOCK_USED)
 219:Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Start();  /* Enable the clock */
 167              		.loc 1 219 0
 168 0040 FF20     		mov	r0, #255
 169 0042 FFF7FEFF 		bl	UART_1_IntClock_StartEx
 220:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 221:Generated_Source\PSoC4/UART_1.c **** 
 222:Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 170              		.loc 1 222 0
 171 0046 FB1D     		add	r3, r7, #7
 172 0048 1B78     		ldrb	r3, [r3]
 173 004a 181C     		mov	r0, r3
 174 004c FFF7FEFF 		bl	CyExitCriticalSection
 223:Generated_Source\PSoC4/UART_1.c **** }
 175              		.loc 1 223 0
 176 0050 BD46     		mov	sp, r7
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 8


 177 0052 03B0     		add	sp, sp, #12
 178              		@ sp needed
 179 0054 90BD     		pop	{r4, r7, pc}
 180              	.L10:
 181 0056 C046     		.align	2
 182              	.L9:
 183 0058 90000F40 		.word	1074725008
 184 005c 91000F40 		.word	1074725009
 185 0060 92000F40 		.word	1074725010
 186              		.cfi_endproc
 187              	.LFE3:
 188              		.size	UART_1_Enable, .-UART_1_Enable
 189              		.section	.text.UART_1_Stop,"ax",%progbits
 190              		.align	2
 191              		.global	UART_1_Stop
 192              		.code	16
 193              		.thumb_func
 194              		.type	UART_1_Stop, %function
 195              	UART_1_Stop:
 196              	.LFB4:
 224:Generated_Source\PSoC4/UART_1.c **** 
 225:Generated_Source\PSoC4/UART_1.c **** 
 226:Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 227:Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Stop
 228:Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 229:Generated_Source\PSoC4/UART_1.c **** *
 230:Generated_Source\PSoC4/UART_1.c **** * Summary:
 231:Generated_Source\PSoC4/UART_1.c **** *  Disables the UART operation.
 232:Generated_Source\PSoC4/UART_1.c **** *
 233:Generated_Source\PSoC4/UART_1.c **** * Parameters:
 234:Generated_Source\PSoC4/UART_1.c **** *  None.
 235:Generated_Source\PSoC4/UART_1.c **** *
 236:Generated_Source\PSoC4/UART_1.c **** * Return:
 237:Generated_Source\PSoC4/UART_1.c **** *  None.
 238:Generated_Source\PSoC4/UART_1.c **** *
 239:Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 240:Generated_Source\PSoC4/UART_1.c **** void UART_1_Stop(void) 
 241:Generated_Source\PSoC4/UART_1.c **** {
 197              		.loc 1 241 0
 198              		.cfi_startproc
 199 0000 90B5     		push	{r4, r7, lr}
 200              		.cfi_def_cfa_offset 12
 201              		.cfi_offset 4, -12
 202              		.cfi_offset 7, -8
 203              		.cfi_offset 14, -4
 204 0002 83B0     		sub	sp, sp, #12
 205              		.cfi_def_cfa_offset 24
 206 0004 00AF     		add	r7, sp, #0
 207              		.cfi_def_cfa_register 7
 242:Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 243:Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 208              		.loc 1 243 0
 209 0006 FC1D     		add	r4, r7, #7
 210 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 211 000c 031C     		mov	r3, r0
 212 000e 2370     		strb	r3, [r4]
 244:Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 9


 245:Generated_Source\PSoC4/UART_1.c ****     /* Write Bit Counter Disable */
 246:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 247:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 213              		.loc 1 247 0
 214 0010 104A     		ldr	r2, .L12
 215 0012 104B     		ldr	r3, .L12
 216 0014 1B78     		ldrb	r3, [r3]
 217 0016 DBB2     		uxtb	r3, r3
 218 0018 2021     		mov	r1, #32
 219 001a 8B43     		bic	r3, r1
 220 001c DBB2     		uxtb	r3, r3
 221 001e 1370     		strb	r3, [r2]
 248:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 249:Generated_Source\PSoC4/UART_1.c **** 
 250:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_ENABLED)
 251:Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 252:Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG &= (uint8) ~UART_1_CNTR_ENABLE;
 253:Generated_Source\PSoC4/UART_1.c ****         #endif /* (!UART_1_TXCLKGEN_DP) */
 254:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_ENABLED) */
 255:Generated_Source\PSoC4/UART_1.c **** 
 256:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_INTERNAL_CLOCK_USED)
 257:Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Stop();   /* Disable the clock */
 222              		.loc 1 257 0
 223 0020 FFF7FEFF 		bl	UART_1_IntClock_Stop
 258:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_INTERNAL_CLOCK_USED) */
 259:Generated_Source\PSoC4/UART_1.c **** 
 260:Generated_Source\PSoC4/UART_1.c ****     /* Disable internal interrupt component */
 261:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 262:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  &= (uint8) ~UART_1_INT_ENABLE;
 224              		.loc 1 262 0
 225 0024 0C4A     		ldr	r2, .L12+4
 226 0026 0C4B     		ldr	r3, .L12+4
 227 0028 1B78     		ldrb	r3, [r3]
 228 002a DBB2     		uxtb	r3, r3
 229 002c 1021     		mov	r1, #16
 230 002e 8B43     		bic	r3, r1
 231 0030 DBB2     		uxtb	r3, r3
 232 0032 1370     		strb	r3, [r2]
 263:Generated_Source\PSoC4/UART_1.c **** 
 264:Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RX_INTERRUPT_ENABLED)
 265:Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableRxInt();
 266:Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 267:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_ENABLED || UART_1_HD_ENABLED) */
 268:Generated_Source\PSoC4/UART_1.c **** 
 269:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_ENABLED)
 270:Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG &= (uint8) ~UART_1_INT_ENABLE;
 233              		.loc 1 270 0
 234 0034 094A     		ldr	r2, .L12+8
 235 0036 094B     		ldr	r3, .L12+8
 236 0038 1B78     		ldrb	r3, [r3]
 237 003a DBB2     		uxtb	r3, r3
 238 003c 1021     		mov	r1, #16
 239 003e 8B43     		bic	r3, r1
 240 0040 DBB2     		uxtb	r3, r3
 241 0042 1370     		strb	r3, [r2]
 271:Generated_Source\PSoC4/UART_1.c **** 
 272:Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 10


 273:Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
 274:Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
 275:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_ENABLED) */
 276:Generated_Source\PSoC4/UART_1.c **** 
 277:Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 242              		.loc 1 277 0
 243 0044 FB1D     		add	r3, r7, #7
 244 0046 1B78     		ldrb	r3, [r3]
 245 0048 181C     		mov	r0, r3
 246 004a FFF7FEFF 		bl	CyExitCriticalSection
 278:Generated_Source\PSoC4/UART_1.c **** }
 247              		.loc 1 278 0
 248 004e BD46     		mov	sp, r7
 249 0050 03B0     		add	sp, sp, #12
 250              		@ sp needed
 251 0052 90BD     		pop	{r4, r7, pc}
 252              	.L13:
 253              		.align	2
 254              	.L12:
 255 0054 90000F40 		.word	1074725008
 256 0058 91000F40 		.word	1074725009
 257 005c 92000F40 		.word	1074725010
 258              		.cfi_endproc
 259              	.LFE4:
 260              		.size	UART_1_Stop, .-UART_1_Stop
 261              		.section	.text.UART_1_ReadControlRegister,"ax",%progbits
 262              		.align	2
 263              		.global	UART_1_ReadControlRegister
 264              		.code	16
 265              		.thumb_func
 266              		.type	UART_1_ReadControlRegister, %function
 267              	UART_1_ReadControlRegister:
 268              	.LFB5:
 279:Generated_Source\PSoC4/UART_1.c **** 
 280:Generated_Source\PSoC4/UART_1.c **** 
 281:Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 282:Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_ReadControlRegister
 283:Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 284:Generated_Source\PSoC4/UART_1.c **** *
 285:Generated_Source\PSoC4/UART_1.c **** * Summary:
 286:Generated_Source\PSoC4/UART_1.c **** *  Returns the current value of the control register.
 287:Generated_Source\PSoC4/UART_1.c **** *
 288:Generated_Source\PSoC4/UART_1.c **** * Parameters:
 289:Generated_Source\PSoC4/UART_1.c **** *  None.
 290:Generated_Source\PSoC4/UART_1.c **** *
 291:Generated_Source\PSoC4/UART_1.c **** * Return:
 292:Generated_Source\PSoC4/UART_1.c **** *  Contents of the control register.
 293:Generated_Source\PSoC4/UART_1.c **** *
 294:Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 295:Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_ReadControlRegister(void) 
 296:Generated_Source\PSoC4/UART_1.c **** {
 269              		.loc 1 296 0
 270              		.cfi_startproc
 271 0000 80B5     		push	{r7, lr}
 272              		.cfi_def_cfa_offset 8
 273              		.cfi_offset 7, -8
 274              		.cfi_offset 14, -4
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 11


 275 0002 00AF     		add	r7, sp, #0
 276              		.cfi_def_cfa_register 7
 297:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_CONTROL_REG_REMOVED)
 298:Generated_Source\PSoC4/UART_1.c ****         return(0u);
 277              		.loc 1 298 0
 278 0004 0023     		mov	r3, #0
 299:Generated_Source\PSoC4/UART_1.c ****     #else
 300:Generated_Source\PSoC4/UART_1.c ****         return(UART_1_CONTROL_REG);
 301:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_CONTROL_REG_REMOVED) */
 302:Generated_Source\PSoC4/UART_1.c **** }
 279              		.loc 1 302 0
 280 0006 181C     		mov	r0, r3
 281 0008 BD46     		mov	sp, r7
 282              		@ sp needed
 283 000a 80BD     		pop	{r7, pc}
 284              		.cfi_endproc
 285              	.LFE5:
 286              		.size	UART_1_ReadControlRegister, .-UART_1_ReadControlRegister
 287              		.section	.text.UART_1_WriteControlRegister,"ax",%progbits
 288              		.align	2
 289              		.global	UART_1_WriteControlRegister
 290              		.code	16
 291              		.thumb_func
 292              		.type	UART_1_WriteControlRegister, %function
 293              	UART_1_WriteControlRegister:
 294              	.LFB6:
 303:Generated_Source\PSoC4/UART_1.c **** 
 304:Generated_Source\PSoC4/UART_1.c **** 
 305:Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 306:Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_WriteControlRegister
 307:Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 308:Generated_Source\PSoC4/UART_1.c **** *
 309:Generated_Source\PSoC4/UART_1.c **** * Summary:
 310:Generated_Source\PSoC4/UART_1.c **** *  Writes an 8-bit value into the control register
 311:Generated_Source\PSoC4/UART_1.c **** *
 312:Generated_Source\PSoC4/UART_1.c **** * Parameters:
 313:Generated_Source\PSoC4/UART_1.c **** *  control:  control register value
 314:Generated_Source\PSoC4/UART_1.c **** *
 315:Generated_Source\PSoC4/UART_1.c **** * Return:
 316:Generated_Source\PSoC4/UART_1.c **** *  None.
 317:Generated_Source\PSoC4/UART_1.c **** *
 318:Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 319:Generated_Source\PSoC4/UART_1.c **** void  UART_1_WriteControlRegister(uint8 control) 
 320:Generated_Source\PSoC4/UART_1.c **** {
 295              		.loc 1 320 0
 296              		.cfi_startproc
 297 0000 80B5     		push	{r7, lr}
 298              		.cfi_def_cfa_offset 8
 299              		.cfi_offset 7, -8
 300              		.cfi_offset 14, -4
 301 0002 82B0     		sub	sp, sp, #8
 302              		.cfi_def_cfa_offset 16
 303 0004 00AF     		add	r7, sp, #0
 304              		.cfi_def_cfa_register 7
 305 0006 021C     		mov	r2, r0
 306 0008 FB1D     		add	r3, r7, #7
 307 000a 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 12


 321:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_CONTROL_REG_REMOVED)
 322:Generated_Source\PSoC4/UART_1.c ****         if(0u != control)
 323:Generated_Source\PSoC4/UART_1.c ****         {
 324:Generated_Source\PSoC4/UART_1.c ****             /* Suppress compiler warning */
 325:Generated_Source\PSoC4/UART_1.c ****         }
 326:Generated_Source\PSoC4/UART_1.c ****     #else
 327:Generated_Source\PSoC4/UART_1.c ****        UART_1_CONTROL_REG = control;
 328:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_CONTROL_REG_REMOVED) */
 329:Generated_Source\PSoC4/UART_1.c **** }
 308              		.loc 1 329 0
 309 000c BD46     		mov	sp, r7
 310 000e 02B0     		add	sp, sp, #8
 311              		@ sp needed
 312 0010 80BD     		pop	{r7, pc}
 313              		.cfi_endproc
 314              	.LFE6:
 315              		.size	UART_1_WriteControlRegister, .-UART_1_WriteControlRegister
 316 0012 C046     		.section	.text.UART_1_SetRxInterruptMode,"ax",%progbits
 317              		.align	2
 318              		.global	UART_1_SetRxInterruptMode
 319              		.code	16
 320              		.thumb_func
 321              		.type	UART_1_SetRxInterruptMode, %function
 322              	UART_1_SetRxInterruptMode:
 323              	.LFB7:
 330:Generated_Source\PSoC4/UART_1.c **** 
 331:Generated_Source\PSoC4/UART_1.c **** 
 332:Generated_Source\PSoC4/UART_1.c **** #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 333:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 334:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxInterruptMode
 335:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 336:Generated_Source\PSoC4/UART_1.c ****     *
 337:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 338:Generated_Source\PSoC4/UART_1.c ****     *  Configures the RX interrupt sources enabled.
 339:Generated_Source\PSoC4/UART_1.c ****     *
 340:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 341:Generated_Source\PSoC4/UART_1.c ****     *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342:Generated_Source\PSoC4/UART_1.c ****     *  bit-field arrangement of the status register. This value must be a 
 343:Generated_Source\PSoC4/UART_1.c ****     *  combination of status register bit-masks shown below:
 344:Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345:Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_PAR_ERROR        Interrupt on parity error.
 346:Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_STOP_ERROR       Interrupt on stop error.
 347:Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_BREAK            Interrupt on break.
 348:Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_OVERRUN          Interrupt on overrun error.
 349:Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_ADDR_MATCH       Interrupt on address match.
 350:Generated_Source\PSoC4/UART_1.c ****     *      UART_1_RX_STS_MRKSPC           Interrupt on address detect.
 351:Generated_Source\PSoC4/UART_1.c ****     *
 352:Generated_Source\PSoC4/UART_1.c ****     * Return:
 353:Generated_Source\PSoC4/UART_1.c ****     *  None.
 354:Generated_Source\PSoC4/UART_1.c ****     *
 355:Generated_Source\PSoC4/UART_1.c ****     * Theory:
 356:Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 357:Generated_Source\PSoC4/UART_1.c ****     *
 358:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 359:Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxInterruptMode(uint8 intSrc) 
 360:Generated_Source\PSoC4/UART_1.c ****     {
 324              		.loc 1 360 0
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 13


 325              		.cfi_startproc
 326 0000 80B5     		push	{r7, lr}
 327              		.cfi_def_cfa_offset 8
 328              		.cfi_offset 7, -8
 329              		.cfi_offset 14, -4
 330 0002 82B0     		sub	sp, sp, #8
 331              		.cfi_def_cfa_offset 16
 332 0004 00AF     		add	r7, sp, #0
 333              		.cfi_def_cfa_register 7
 334 0006 021C     		mov	r2, r0
 335 0008 FB1D     		add	r3, r7, #7
 336 000a 1A70     		strb	r2, [r3]
 361:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = intSrc;
 337              		.loc 1 361 0
 338 000c 034A     		ldr	r2, .L18
 339 000e FB1D     		add	r3, r7, #7
 340 0010 1B78     		ldrb	r3, [r3]
 341 0012 1370     		strb	r3, [r2]
 362:Generated_Source\PSoC4/UART_1.c ****     }
 342              		.loc 1 362 0
 343 0014 BD46     		mov	sp, r7
 344 0016 02B0     		add	sp, sp, #8
 345              		@ sp needed
 346 0018 80BD     		pop	{r7, pc}
 347              	.L19:
 348 001a C046     		.align	2
 349              	.L18:
 350 001c 81000F40 		.word	1074724993
 351              		.cfi_endproc
 352              	.LFE7:
 353              		.size	UART_1_SetRxInterruptMode, .-UART_1_SetRxInterruptMode
 354              		.section	.text.UART_1_ReadRxData,"ax",%progbits
 355              		.align	2
 356              		.global	UART_1_ReadRxData
 357              		.code	16
 358              		.thumb_func
 359              		.type	UART_1_ReadRxData, %function
 360              	UART_1_ReadRxData:
 361              	.LFB8:
 363:Generated_Source\PSoC4/UART_1.c **** 
 364:Generated_Source\PSoC4/UART_1.c **** 
 365:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 366:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxData
 367:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 368:Generated_Source\PSoC4/UART_1.c ****     *
 369:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 370:Generated_Source\PSoC4/UART_1.c ****     *  Returns the next byte of received data. This function returns data without
 371:Generated_Source\PSoC4/UART_1.c ****     *  checking the status. You must check the status separately.
 372:Generated_Source\PSoC4/UART_1.c ****     *
 373:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 374:Generated_Source\PSoC4/UART_1.c ****     *  None.
 375:Generated_Source\PSoC4/UART_1.c ****     *
 376:Generated_Source\PSoC4/UART_1.c ****     * Return:
 377:Generated_Source\PSoC4/UART_1.c ****     *  Received data from RX register
 378:Generated_Source\PSoC4/UART_1.c ****     *
 379:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 380:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 14


 381:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 382:Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 383:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 384:Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 385:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
 386:Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 387:Generated_Source\PSoC4/UART_1.c ****     *
 388:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 389:Generated_Source\PSoC4/UART_1.c ****     *  No.
 390:Generated_Source\PSoC4/UART_1.c ****     *
 391:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 392:Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxData(void) 
 393:Generated_Source\PSoC4/UART_1.c ****     {
 362              		.loc 1 393 0
 363              		.cfi_startproc
 364 0000 80B5     		push	{r7, lr}
 365              		.cfi_def_cfa_offset 8
 366              		.cfi_offset 7, -8
 367              		.cfi_offset 14, -4
 368 0002 82B0     		sub	sp, sp, #8
 369              		.cfi_def_cfa_offset 16
 370 0004 00AF     		add	r7, sp, #0
 371              		.cfi_def_cfa_register 7
 394:Generated_Source\PSoC4/UART_1.c ****         uint8 rxData;
 395:Generated_Source\PSoC4/UART_1.c **** 
 396:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 397:Generated_Source\PSoC4/UART_1.c **** 
 398:Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferRead;
 399:Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferWrite;
 400:Generated_Source\PSoC4/UART_1.c **** 
 401:Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 402:Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 403:Generated_Source\PSoC4/UART_1.c **** 
 404:Generated_Source\PSoC4/UART_1.c ****         locRxBufferRead  = UART_1_rxBufferRead;
 405:Generated_Source\PSoC4/UART_1.c ****         locRxBufferWrite = UART_1_rxBufferWrite;
 406:Generated_Source\PSoC4/UART_1.c **** 
 407:Generated_Source\PSoC4/UART_1.c ****         if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 408:Generated_Source\PSoC4/UART_1.c ****         {
 409:Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_rxBuffer[locRxBufferRead];
 410:Generated_Source\PSoC4/UART_1.c ****             locRxBufferRead++;
 411:Generated_Source\PSoC4/UART_1.c **** 
 412:Generated_Source\PSoC4/UART_1.c ****             if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
 413:Generated_Source\PSoC4/UART_1.c ****             {
 414:Generated_Source\PSoC4/UART_1.c ****                 locRxBufferRead = 0u;
 415:Generated_Source\PSoC4/UART_1.c ****             }
 416:Generated_Source\PSoC4/UART_1.c ****             /* Update the real pointer */
 417:Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferRead = locRxBufferRead;
 418:Generated_Source\PSoC4/UART_1.c **** 
 419:Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 420:Generated_Source\PSoC4/UART_1.c ****             {
 421:Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferLoopDetect = 0u;
 422:Generated_Source\PSoC4/UART_1.c ****                 #if ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u))
 423:Generated_Source\PSoC4/UART_1.c ****                     /* When Hardware Flow Control selected - return RX mask */
 424:Generated_Source\PSoC4/UART_1.c ****                     #if( UART_1_HD_ENABLED )
 425:Generated_Source\PSoC4/UART_1.c ****                         if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 426:Generated_Source\PSoC4/UART_1.c ****                         {   /* In Half duplex mode return RX mask only in RX
 427:Generated_Source\PSoC4/UART_1.c ****                             *  configuration set, otherwise
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 15


 428:Generated_Source\PSoC4/UART_1.c ****                             *  mask will be returned in LoadRxConfig() API.
 429:Generated_Source\PSoC4/UART_1.c ****                             */
 430:Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 431:Generated_Source\PSoC4/UART_1.c ****                         }
 432:Generated_Source\PSoC4/UART_1.c ****                     #else
 433:Generated_Source\PSoC4/UART_1.c ****                         UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 434:Generated_Source\PSoC4/UART_1.c ****                     #endif /* end UART_1_HD_ENABLED */
 435:Generated_Source\PSoC4/UART_1.c ****                 #endif /* ((UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u)) */
 436:Generated_Source\PSoC4/UART_1.c ****             }
 437:Generated_Source\PSoC4/UART_1.c ****         }
 438:Generated_Source\PSoC4/UART_1.c ****         else
 439:Generated_Source\PSoC4/UART_1.c ****         {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 440:Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 441:Generated_Source\PSoC4/UART_1.c ****         }
 442:Generated_Source\PSoC4/UART_1.c **** 
 443:Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 444:Generated_Source\PSoC4/UART_1.c **** 
 445:Generated_Source\PSoC4/UART_1.c ****     #else
 446:Generated_Source\PSoC4/UART_1.c **** 
 447:Generated_Source\PSoC4/UART_1.c ****         /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 448:Generated_Source\PSoC4/UART_1.c ****         rxData = UART_1_RXDATA_REG;
 372              		.loc 1 448 0
 373 0006 054A     		ldr	r2, .L22
 374 0008 FB1D     		add	r3, r7, #7
 375 000a 1278     		ldrb	r2, [r2]
 376 000c 1A70     		strb	r2, [r3]
 449:Generated_Source\PSoC4/UART_1.c **** 
 450:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 451:Generated_Source\PSoC4/UART_1.c **** 
 452:Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 377              		.loc 1 452 0
 378 000e FB1D     		add	r3, r7, #7
 379 0010 1B78     		ldrb	r3, [r3]
 453:Generated_Source\PSoC4/UART_1.c ****     }
 380              		.loc 1 453 0
 381 0012 181C     		mov	r0, r3
 382 0014 BD46     		mov	sp, r7
 383 0016 02B0     		add	sp, sp, #8
 384              		@ sp needed
 385 0018 80BD     		pop	{r7, pc}
 386              	.L23:
 387 001a C046     		.align	2
 388              	.L22:
 389 001c 40000F40 		.word	1074724928
 390              		.cfi_endproc
 391              	.LFE8:
 392              		.size	UART_1_ReadRxData, .-UART_1_ReadRxData
 393              		.section	.text.UART_1_ReadRxStatus,"ax",%progbits
 394              		.align	2
 395              		.global	UART_1_ReadRxStatus
 396              		.code	16
 397              		.thumb_func
 398              		.type	UART_1_ReadRxStatus, %function
 399              	UART_1_ReadRxStatus:
 400              	.LFB9:
 454:Generated_Source\PSoC4/UART_1.c **** 
 455:Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 16


 456:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 457:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxStatus
 458:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 459:Generated_Source\PSoC4/UART_1.c ****     *
 460:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 461:Generated_Source\PSoC4/UART_1.c ****     *  Returns the current state of the receiver status register and the software
 462:Generated_Source\PSoC4/UART_1.c ****     *  buffer overflow status.
 463:Generated_Source\PSoC4/UART_1.c ****     *
 464:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 465:Generated_Source\PSoC4/UART_1.c ****     *  None.
 466:Generated_Source\PSoC4/UART_1.c ****     *
 467:Generated_Source\PSoC4/UART_1.c ****     * Return:
 468:Generated_Source\PSoC4/UART_1.c ****     *  Current state of the status register.
 469:Generated_Source\PSoC4/UART_1.c ****     *
 470:Generated_Source\PSoC4/UART_1.c ****     * Side Effect:
 471:Generated_Source\PSoC4/UART_1.c ****     *  All status register bits are clear-on-read except
 472:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_RX_STS_FIFO_NOTEMPTY.
 473:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474:Generated_Source\PSoC4/UART_1.c ****     *  register read.
 475:Generated_Source\PSoC4/UART_1.c ****     *
 476:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 477:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - used to indicate overload condition.
 478:Generated_Source\PSoC4/UART_1.c ****     *   It set to one in RX interrupt when there isn't free space in
 479:Generated_Source\PSoC4/UART_1.c ****     *   UART_1_rxBufferRead to write new data. This condition returned
 480:Generated_Source\PSoC4/UART_1.c ****     *   and cleared to zero by this API as an
 481:Generated_Source\PSoC4/UART_1.c ****     *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482:Generated_Source\PSoC4/UART_1.c ****     *   bits.
 483:Generated_Source\PSoC4/UART_1.c ****     *
 484:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 485:Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxStatus(void) 
 486:Generated_Source\PSoC4/UART_1.c ****     {
 401              		.loc 1 486 0
 402              		.cfi_startproc
 403 0000 80B5     		push	{r7, lr}
 404              		.cfi_def_cfa_offset 8
 405              		.cfi_offset 7, -8
 406              		.cfi_offset 14, -4
 407 0002 82B0     		sub	sp, sp, #8
 408              		.cfi_def_cfa_offset 16
 409 0004 00AF     		add	r7, sp, #0
 410              		.cfi_def_cfa_register 7
 487:Generated_Source\PSoC4/UART_1.c ****         uint8 status;
 488:Generated_Source\PSoC4/UART_1.c **** 
 489:Generated_Source\PSoC4/UART_1.c ****         status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
 411              		.loc 1 489 0
 412 0006 064B     		ldr	r3, .L26
 413 0008 1B78     		ldrb	r3, [r3]
 414 000a DAB2     		uxtb	r2, r3
 415 000c FB1D     		add	r3, r7, #7
 416 000e 7F21     		mov	r1, #127
 417 0010 0A40     		and	r2, r1
 418 0012 1A70     		strb	r2, [r3]
 490:Generated_Source\PSoC4/UART_1.c **** 
 491:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 492:Generated_Source\PSoC4/UART_1.c ****         if(UART_1_rxBufferOverflow != 0u)
 493:Generated_Source\PSoC4/UART_1.c ****         {
 494:Generated_Source\PSoC4/UART_1.c ****             status |= UART_1_RX_STS_SOFT_BUFF_OVER;
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 17


 495:Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferOverflow = 0u;
 496:Generated_Source\PSoC4/UART_1.c ****         }
 497:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 498:Generated_Source\PSoC4/UART_1.c **** 
 499:Generated_Source\PSoC4/UART_1.c ****         return(status);
 419              		.loc 1 499 0
 420 0014 FB1D     		add	r3, r7, #7
 421 0016 1B78     		ldrb	r3, [r3]
 500:Generated_Source\PSoC4/UART_1.c ****     }
 422              		.loc 1 500 0
 423 0018 181C     		mov	r0, r3
 424 001a BD46     		mov	sp, r7
 425 001c 02B0     		add	sp, sp, #8
 426              		@ sp needed
 427 001e 80BD     		pop	{r7, pc}
 428              	.L27:
 429              		.align	2
 430              	.L26:
 431 0020 61000F40 		.word	1074724961
 432              		.cfi_endproc
 433              	.LFE9:
 434              		.size	UART_1_ReadRxStatus, .-UART_1_ReadRxStatus
 435              		.section	.text.UART_1_GetChar,"ax",%progbits
 436              		.align	2
 437              		.global	UART_1_GetChar
 438              		.code	16
 439              		.thumb_func
 440              		.type	UART_1_GetChar, %function
 441              	UART_1_GetChar:
 442              	.LFB10:
 501:Generated_Source\PSoC4/UART_1.c **** 
 502:Generated_Source\PSoC4/UART_1.c **** 
 503:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 504:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetChar
 505:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 506:Generated_Source\PSoC4/UART_1.c ****     *
 507:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 508:Generated_Source\PSoC4/UART_1.c ****     *  Returns the last received byte of data. UART_1_GetChar() is
 509:Generated_Source\PSoC4/UART_1.c ****     *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510:Generated_Source\PSoC4/UART_1.c ****     *  for valid characters and 0 indicates an error occurred or no data is present.
 511:Generated_Source\PSoC4/UART_1.c ****     *
 512:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 513:Generated_Source\PSoC4/UART_1.c ****     *  None.
 514:Generated_Source\PSoC4/UART_1.c ****     *
 515:Generated_Source\PSoC4/UART_1.c ****     * Return:
 516:Generated_Source\PSoC4/UART_1.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517:Generated_Source\PSoC4/UART_1.c ****     *  A returned zero signifies an error condition or no data available.
 518:Generated_Source\PSoC4/UART_1.c ****     *
 519:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 520:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 521:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 522:Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 523:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 524:Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 525:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared if loop condition was detected
 526:Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 527:Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 18


 528:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 529:Generated_Source\PSoC4/UART_1.c ****     *  No.
 530:Generated_Source\PSoC4/UART_1.c ****     *
 531:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 532:Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetChar(void) 
 533:Generated_Source\PSoC4/UART_1.c ****     {
 443              		.loc 1 533 0
 444              		.cfi_startproc
 445 0000 80B5     		push	{r7, lr}
 446              		.cfi_def_cfa_offset 8
 447              		.cfi_offset 7, -8
 448              		.cfi_offset 14, -4
 449 0002 82B0     		sub	sp, sp, #8
 450              		.cfi_def_cfa_offset 16
 451 0004 00AF     		add	r7, sp, #0
 452              		.cfi_def_cfa_register 7
 534:Generated_Source\PSoC4/UART_1.c ****         uint8 rxData = 0u;
 453              		.loc 1 534 0
 454 0006 FB1D     		add	r3, r7, #7
 455 0008 0022     		mov	r2, #0
 456 000a 1A70     		strb	r2, [r3]
 535:Generated_Source\PSoC4/UART_1.c ****         uint8 rxStatus;
 536:Generated_Source\PSoC4/UART_1.c **** 
 537:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 538:Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferRead;
 539:Generated_Source\PSoC4/UART_1.c ****         uint8 locRxBufferWrite;
 540:Generated_Source\PSoC4/UART_1.c **** 
 541:Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 542:Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 543:Generated_Source\PSoC4/UART_1.c **** 
 544:Generated_Source\PSoC4/UART_1.c ****         locRxBufferRead  = UART_1_rxBufferRead;
 545:Generated_Source\PSoC4/UART_1.c ****         locRxBufferWrite = UART_1_rxBufferWrite;
 546:Generated_Source\PSoC4/UART_1.c **** 
 547:Generated_Source\PSoC4/UART_1.c ****         if( (UART_1_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 548:Generated_Source\PSoC4/UART_1.c ****         {
 549:Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_rxBuffer[locRxBufferRead];
 550:Generated_Source\PSoC4/UART_1.c ****             locRxBufferRead++;
 551:Generated_Source\PSoC4/UART_1.c ****             if(locRxBufferRead >= UART_1_RX_BUFFER_SIZE)
 552:Generated_Source\PSoC4/UART_1.c ****             {
 553:Generated_Source\PSoC4/UART_1.c ****                 locRxBufferRead = 0u;
 554:Generated_Source\PSoC4/UART_1.c ****             }
 555:Generated_Source\PSoC4/UART_1.c ****             /* Update the real pointer */
 556:Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferRead = locRxBufferRead;
 557:Generated_Source\PSoC4/UART_1.c **** 
 558:Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 559:Generated_Source\PSoC4/UART_1.c ****             {
 560:Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferLoopDetect = 0u;
 561:Generated_Source\PSoC4/UART_1.c ****                 #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
 562:Generated_Source\PSoC4/UART_1.c ****                     /* When Hardware Flow Control selected - return RX mask */
 563:Generated_Source\PSoC4/UART_1.c ****                     #if( UART_1_HD_ENABLED )
 564:Generated_Source\PSoC4/UART_1.c ****                         if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 565:Generated_Source\PSoC4/UART_1.c ****                         {   /* In Half duplex mode return RX mask only if
 566:Generated_Source\PSoC4/UART_1.c ****                             *  RX configuration set, otherwise
 567:Generated_Source\PSoC4/UART_1.c ****                             *  mask will be returned in LoadRxConfig() API.
 568:Generated_Source\PSoC4/UART_1.c ****                             */
 569:Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
 570:Generated_Source\PSoC4/UART_1.c ****                         }
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 19


 571:Generated_Source\PSoC4/UART_1.c ****                     #else
 572:Generated_Source\PSoC4/UART_1.c ****                         UART_1_RXSTATUS_MASK_REG |= UART_1_RX_STS_FIFO_NOTEMPTY;
 573:Generated_Source\PSoC4/UART_1.c ****                     #endif /* end UART_1_HD_ENABLED */
 574:Generated_Source\PSoC4/UART_1.c ****                 #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 575:Generated_Source\PSoC4/UART_1.c ****             }
 576:Generated_Source\PSoC4/UART_1.c **** 
 577:Generated_Source\PSoC4/UART_1.c ****         }
 578:Generated_Source\PSoC4/UART_1.c ****         else
 579:Generated_Source\PSoC4/UART_1.c ****         {   rxStatus = UART_1_RXSTATUS_REG;
 580:Generated_Source\PSoC4/UART_1.c ****             if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 581:Generated_Source\PSoC4/UART_1.c ****             {   /* Read received data from FIFO */
 582:Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 583:Generated_Source\PSoC4/UART_1.c ****                 /*Check status on error*/
 584:Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 585:Generated_Source\PSoC4/UART_1.c ****                                 UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 586:Generated_Source\PSoC4/UART_1.c ****                 {
 587:Generated_Source\PSoC4/UART_1.c ****                     rxData = 0u;
 588:Generated_Source\PSoC4/UART_1.c ****                 }
 589:Generated_Source\PSoC4/UART_1.c ****             }
 590:Generated_Source\PSoC4/UART_1.c ****         }
 591:Generated_Source\PSoC4/UART_1.c **** 
 592:Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 593:Generated_Source\PSoC4/UART_1.c **** 
 594:Generated_Source\PSoC4/UART_1.c ****     #else
 595:Generated_Source\PSoC4/UART_1.c **** 
 596:Generated_Source\PSoC4/UART_1.c ****         rxStatus =UART_1_RXSTATUS_REG;
 457              		.loc 1 596 0
 458 000c 0D4A     		ldr	r2, .L31
 459 000e BB1D     		add	r3, r7, #6
 460 0010 1278     		ldrb	r2, [r2]
 461 0012 1A70     		strb	r2, [r3]
 597:Generated_Source\PSoC4/UART_1.c ****         if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 462              		.loc 1 597 0
 463 0014 BB1D     		add	r3, r7, #6
 464 0016 1B78     		ldrb	r3, [r3]
 465 0018 2022     		mov	r2, #32
 466 001a 1340     		and	r3, r2
 467 001c 0BD0     		beq	.L29
 598:Generated_Source\PSoC4/UART_1.c ****         {
 599:Generated_Source\PSoC4/UART_1.c ****             /* Read received data from FIFO */
 600:Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 468              		.loc 1 600 0
 469 001e 0A4A     		ldr	r2, .L31+4
 470 0020 FB1D     		add	r3, r7, #7
 471 0022 1278     		ldrb	r2, [r2]
 472 0024 1A70     		strb	r2, [r3]
 601:Generated_Source\PSoC4/UART_1.c **** 
 602:Generated_Source\PSoC4/UART_1.c ****             /*Check status on error*/
 603:Generated_Source\PSoC4/UART_1.c ****             if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 604:Generated_Source\PSoC4/UART_1.c ****                             UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 473              		.loc 1 604 0
 474 0026 BB1D     		add	r3, r7, #6
 475 0028 1B78     		ldrb	r3, [r3]
 476 002a 1E22     		mov	r2, #30
 477 002c 1340     		and	r3, r2
 603:Generated_Source\PSoC4/UART_1.c ****                             UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 478              		.loc 1 603 0
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 20


 479 002e 02D0     		beq	.L29
 605:Generated_Source\PSoC4/UART_1.c ****             {
 606:Generated_Source\PSoC4/UART_1.c ****                 rxData = 0u;
 480              		.loc 1 606 0
 481 0030 FB1D     		add	r3, r7, #7
 482 0032 0022     		mov	r2, #0
 483 0034 1A70     		strb	r2, [r3]
 484              	.L29:
 607:Generated_Source\PSoC4/UART_1.c ****             }
 608:Generated_Source\PSoC4/UART_1.c ****         }
 609:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 610:Generated_Source\PSoC4/UART_1.c **** 
 611:Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 485              		.loc 1 611 0
 486 0036 FB1D     		add	r3, r7, #7
 487 0038 1B78     		ldrb	r3, [r3]
 612:Generated_Source\PSoC4/UART_1.c ****     }
 488              		.loc 1 612 0
 489 003a 181C     		mov	r0, r3
 490 003c BD46     		mov	sp, r7
 491 003e 02B0     		add	sp, sp, #8
 492              		@ sp needed
 493 0040 80BD     		pop	{r7, pc}
 494              	.L32:
 495 0042 C046     		.align	2
 496              	.L31:
 497 0044 61000F40 		.word	1074724961
 498 0048 40000F40 		.word	1074724928
 499              		.cfi_endproc
 500              	.LFE10:
 501              		.size	UART_1_GetChar, .-UART_1_GetChar
 502              		.section	.text.UART_1_GetByte,"ax",%progbits
 503              		.align	2
 504              		.global	UART_1_GetByte
 505              		.code	16
 506              		.thumb_func
 507              		.type	UART_1_GetByte, %function
 508              	UART_1_GetByte:
 509              	.LFB11:
 613:Generated_Source\PSoC4/UART_1.c **** 
 614:Generated_Source\PSoC4/UART_1.c **** 
 615:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 616:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetByte
 617:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 618:Generated_Source\PSoC4/UART_1.c ****     *
 619:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 620:Generated_Source\PSoC4/UART_1.c ****     *  Reads UART RX buffer immediately, returns received character and error
 621:Generated_Source\PSoC4/UART_1.c ****     *  condition.
 622:Generated_Source\PSoC4/UART_1.c ****     *
 623:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 624:Generated_Source\PSoC4/UART_1.c ****     *  None.
 625:Generated_Source\PSoC4/UART_1.c ****     *
 626:Generated_Source\PSoC4/UART_1.c ****     * Return:
 627:Generated_Source\PSoC4/UART_1.c ****     *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628:Generated_Source\PSoC4/UART_1.c ****     *  an error has occurred.
 629:Generated_Source\PSoC4/UART_1.c ****     *
 630:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 21


 631:Generated_Source\PSoC4/UART_1.c ****     *  No.
 632:Generated_Source\PSoC4/UART_1.c ****     *
 633:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 634:Generated_Source\PSoC4/UART_1.c ****     uint16 UART_1_GetByte(void) 
 635:Generated_Source\PSoC4/UART_1.c ****     {
 510              		.loc 1 635 0
 511              		.cfi_startproc
 512 0000 98B5     		push	{r3, r4, r7, lr}
 513              		.cfi_def_cfa_offset 16
 514              		.cfi_offset 3, -16
 515              		.cfi_offset 4, -12
 516              		.cfi_offset 7, -8
 517              		.cfi_offset 14, -4
 518 0002 00AF     		add	r7, sp, #0
 519              		.cfi_def_cfa_register 7
 636:Generated_Source\PSoC4/UART_1.c ****         
 637:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 638:Generated_Source\PSoC4/UART_1.c ****         uint16 locErrorStatus;
 639:Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 640:Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 641:Generated_Source\PSoC4/UART_1.c ****         locErrorStatus = (uint16)UART_1_errorStatus;
 642:Generated_Source\PSoC4/UART_1.c ****         UART_1_errorStatus = 0u;
 643:Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 644:Generated_Source\PSoC4/UART_1.c ****         return ( (uint16)(locErrorStatus << 8u) | UART_1_ReadRxData() );
 645:Generated_Source\PSoC4/UART_1.c ****     #else
 646:Generated_Source\PSoC4/UART_1.c ****         return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 520              		.loc 1 646 0
 521 0004 FFF7FEFF 		bl	UART_1_ReadRxStatus
 522 0008 031C     		mov	r3, r0
 523 000a 1B02     		lsl	r3, r3, #8
 524 000c 9CB2     		uxth	r4, r3
 525 000e FFF7FEFF 		bl	UART_1_ReadRxData
 526 0012 031C     		mov	r3, r0
 527 0014 9BB2     		uxth	r3, r3
 528 0016 221C     		add	r2, r4, #0
 529 0018 1343     		orr	r3, r2
 530 001a 9BB2     		uxth	r3, r3
 531 001c 9BB2     		uxth	r3, r3
 647:Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_RX_INTERRUPT_ENABLED */
 648:Generated_Source\PSoC4/UART_1.c ****         
 649:Generated_Source\PSoC4/UART_1.c ****     }
 532              		.loc 1 649 0
 533 001e 181C     		mov	r0, r3
 534 0020 BD46     		mov	sp, r7
 535              		@ sp needed
 536 0022 98BD     		pop	{r3, r4, r7, pc}
 537              		.cfi_endproc
 538              	.LFE11:
 539              		.size	UART_1_GetByte, .-UART_1_GetByte
 540              		.section	.text.UART_1_GetRxBufferSize,"ax",%progbits
 541              		.align	2
 542              		.global	UART_1_GetRxBufferSize
 543              		.code	16
 544              		.thumb_func
 545              		.type	UART_1_GetRxBufferSize, %function
 546              	UART_1_GetRxBufferSize:
 547              	.LFB12:
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 22


 650:Generated_Source\PSoC4/UART_1.c **** 
 651:Generated_Source\PSoC4/UART_1.c **** 
 652:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 653:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetRxBufferSize
 654:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 655:Generated_Source\PSoC4/UART_1.c ****     *
 656:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 657:Generated_Source\PSoC4/UART_1.c ****     *  Returns the number of received bytes available in the RX buffer.
 658:Generated_Source\PSoC4/UART_1.c ****     *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659:Generated_Source\PSoC4/UART_1.c ****     *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660:Generated_Source\PSoC4/UART_1.c ****     *  * RX software buffer is enabled: returns the number of bytes available in 
 661:Generated_Source\PSoC4/UART_1.c ****     *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662:Generated_Source\PSoC4/UART_1.c ****     *    account.
 663:Generated_Source\PSoC4/UART_1.c ****     *
 664:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 665:Generated_Source\PSoC4/UART_1.c ****     *  None.
 666:Generated_Source\PSoC4/UART_1.c ****     *
 667:Generated_Source\PSoC4/UART_1.c ****     * Return:
 668:Generated_Source\PSoC4/UART_1.c ****     *  uint8: Number of bytes in the RX buffer. 
 669:Generated_Source\PSoC4/UART_1.c ****     *    Return value type depends on RX Buffer Size parameter.
 670:Generated_Source\PSoC4/UART_1.c ****     *
 671:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 672:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - used to calculate left bytes.
 673:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - used to calculate left bytes.
 674:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 675:Generated_Source\PSoC4/UART_1.c ****     *
 676:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 677:Generated_Source\PSoC4/UART_1.c ****     *  No.
 678:Generated_Source\PSoC4/UART_1.c ****     *
 679:Generated_Source\PSoC4/UART_1.c ****     * Theory:
 680:Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the RX Buffer is.
 681:Generated_Source\PSoC4/UART_1.c ****     *
 682:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 683:Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetRxBufferSize(void)
 684:Generated_Source\PSoC4/UART_1.c ****                                                             
 685:Generated_Source\PSoC4/UART_1.c ****     {
 548              		.loc 1 685 0
 549              		.cfi_startproc
 550 0000 80B5     		push	{r7, lr}
 551              		.cfi_def_cfa_offset 8
 552              		.cfi_offset 7, -8
 553              		.cfi_offset 14, -4
 554 0002 82B0     		sub	sp, sp, #8
 555              		.cfi_def_cfa_offset 16
 556 0004 00AF     		add	r7, sp, #0
 557              		.cfi_def_cfa_register 7
 686:Generated_Source\PSoC4/UART_1.c ****         uint8 size;
 687:Generated_Source\PSoC4/UART_1.c **** 
 688:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 689:Generated_Source\PSoC4/UART_1.c **** 
 690:Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt */
 691:Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 692:Generated_Source\PSoC4/UART_1.c **** 
 693:Generated_Source\PSoC4/UART_1.c ****         if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
 694:Generated_Source\PSoC4/UART_1.c ****         {
 695:Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferLoopDetect != 0u)
 696:Generated_Source\PSoC4/UART_1.c ****             {
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 23


 697:Generated_Source\PSoC4/UART_1.c ****                 size = UART_1_RX_BUFFER_SIZE;
 698:Generated_Source\PSoC4/UART_1.c ****             }
 699:Generated_Source\PSoC4/UART_1.c ****             else
 700:Generated_Source\PSoC4/UART_1.c ****             {
 701:Generated_Source\PSoC4/UART_1.c ****                 size = 0u;
 702:Generated_Source\PSoC4/UART_1.c ****             }
 703:Generated_Source\PSoC4/UART_1.c ****         }
 704:Generated_Source\PSoC4/UART_1.c ****         else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
 705:Generated_Source\PSoC4/UART_1.c ****         {
 706:Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
 707:Generated_Source\PSoC4/UART_1.c ****         }
 708:Generated_Source\PSoC4/UART_1.c ****         else
 709:Generated_Source\PSoC4/UART_1.c ****         {
 710:Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_RX_BUFFER_SIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
 711:Generated_Source\PSoC4/UART_1.c ****         }
 712:Generated_Source\PSoC4/UART_1.c **** 
 713:Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 714:Generated_Source\PSoC4/UART_1.c **** 
 715:Generated_Source\PSoC4/UART_1.c ****     #else
 716:Generated_Source\PSoC4/UART_1.c **** 
 717:Generated_Source\PSoC4/UART_1.c ****         /* We can only know if there is data in the fifo. */
 718:Generated_Source\PSoC4/UART_1.c ****         size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 558              		.loc 1 718 0
 559 0006 094B     		ldr	r3, .L39
 560 0008 1B78     		ldrb	r3, [r3]
 561 000a DBB2     		uxtb	r3, r3
 562 000c 1A1C     		mov	r2, r3
 563 000e 2023     		mov	r3, #32
 564 0010 1340     		and	r3, r2
 565 0012 01D0     		beq	.L36
 566              		.loc 1 718 0 is_stmt 0 discriminator 1
 567 0014 0122     		mov	r2, #1
 568 0016 00E0     		b	.L37
 569              	.L36:
 570              		.loc 1 718 0 discriminator 2
 571 0018 0022     		mov	r2, #0
 572              	.L37:
 573              		.loc 1 718 0 discriminator 4
 574 001a FB1D     		add	r3, r7, #7
 575 001c 1A70     		strb	r2, [r3]
 719:Generated_Source\PSoC4/UART_1.c **** 
 720:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 721:Generated_Source\PSoC4/UART_1.c **** 
 722:Generated_Source\PSoC4/UART_1.c ****         return(size);
 576              		.loc 1 722 0 is_stmt 1 discriminator 4
 577 001e FB1D     		add	r3, r7, #7
 578 0020 1B78     		ldrb	r3, [r3]
 723:Generated_Source\PSoC4/UART_1.c ****     }
 579              		.loc 1 723 0 discriminator 4
 580 0022 181C     		mov	r0, r3
 581 0024 BD46     		mov	sp, r7
 582 0026 02B0     		add	sp, sp, #8
 583              		@ sp needed
 584 0028 80BD     		pop	{r7, pc}
 585              	.L40:
 586 002a C046     		.align	2
 587              	.L39:
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 24


 588 002c 61000F40 		.word	1074724961
 589              		.cfi_endproc
 590              	.LFE12:
 591              		.size	UART_1_GetRxBufferSize, .-UART_1_GetRxBufferSize
 592              		.section	.text.UART_1_ClearRxBuffer,"ax",%progbits
 593              		.align	2
 594              		.global	UART_1_ClearRxBuffer
 595              		.code	16
 596              		.thumb_func
 597              		.type	UART_1_ClearRxBuffer, %function
 598              	UART_1_ClearRxBuffer:
 599              	.LFB13:
 724:Generated_Source\PSoC4/UART_1.c **** 
 725:Generated_Source\PSoC4/UART_1.c **** 
 726:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 727:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearRxBuffer
 728:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 729:Generated_Source\PSoC4/UART_1.c ****     *
 730:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 731:Generated_Source\PSoC4/UART_1.c ****     *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732:Generated_Source\PSoC4/UART_1.c ****     *
 733:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 734:Generated_Source\PSoC4/UART_1.c ****     *  None.
 735:Generated_Source\PSoC4/UART_1.c ****     *
 736:Generated_Source\PSoC4/UART_1.c ****     * Return:
 737:Generated_Source\PSoC4/UART_1.c ****     *  None.
 738:Generated_Source\PSoC4/UART_1.c ****     *
 739:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 740:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cleared to zero.
 741:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cleared to zero.
 742:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared to zero.
 743:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - cleared to zero.
 744:Generated_Source\PSoC4/UART_1.c ****     *
 745:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 746:Generated_Source\PSoC4/UART_1.c ****     *  No.
 747:Generated_Source\PSoC4/UART_1.c ****     *
 748:Generated_Source\PSoC4/UART_1.c ****     * Theory:
 749:Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 750:Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may
 751:Generated_Source\PSoC4/UART_1.c ****     *  have remained in the RAM.
 752:Generated_Source\PSoC4/UART_1.c ****     *
 753:Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
 754:Generated_Source\PSoC4/UART_1.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 755:Generated_Source\PSoC4/UART_1.c ****     *
 756:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 757:Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearRxBuffer(void) 
 758:Generated_Source\PSoC4/UART_1.c ****     {
 600              		.loc 1 758 0
 601              		.cfi_startproc
 602 0000 90B5     		push	{r4, r7, lr}
 603              		.cfi_def_cfa_offset 12
 604              		.cfi_offset 4, -12
 605              		.cfi_offset 7, -8
 606              		.cfi_offset 14, -4
 607 0002 83B0     		sub	sp, sp, #12
 608              		.cfi_def_cfa_offset 24
 609 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 25


 610              		.cfi_def_cfa_register 7
 759:Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
 760:Generated_Source\PSoC4/UART_1.c **** 
 761:Generated_Source\PSoC4/UART_1.c ****         /* Clear the HW FIFO */
 762:Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 611              		.loc 1 762 0
 612 0006 FC1D     		add	r4, r7, #7
 613 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 614 000c 031C     		mov	r3, r0
 615 000e 2370     		strb	r3, [r4]
 763:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG |= (uint8)  UART_1_RX_FIFO_CLR;
 616              		.loc 1 763 0
 617 0010 0B4A     		ldr	r2, .L42
 618 0012 0B4B     		ldr	r3, .L42
 619 0014 1B78     		ldrb	r3, [r3]
 620 0016 DBB2     		uxtb	r3, r3
 621 0018 0121     		mov	r1, #1
 622 001a 0B43     		orr	r3, r1
 623 001c DBB2     		uxtb	r3, r3
 624 001e 1370     		strb	r3, [r2]
 764:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG &= (uint8) ~UART_1_RX_FIFO_CLR;
 625              		.loc 1 764 0
 626 0020 074A     		ldr	r2, .L42
 627 0022 074B     		ldr	r3, .L42
 628 0024 1B78     		ldrb	r3, [r3]
 629 0026 DBB2     		uxtb	r3, r3
 630 0028 0121     		mov	r1, #1
 631 002a 8B43     		bic	r3, r1
 632 002c DBB2     		uxtb	r3, r3
 633 002e 1370     		strb	r3, [r2]
 765:Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 634              		.loc 1 765 0
 635 0030 FB1D     		add	r3, r7, #7
 636 0032 1B78     		ldrb	r3, [r3]
 637 0034 181C     		mov	r0, r3
 638 0036 FFF7FEFF 		bl	CyExitCriticalSection
 766:Generated_Source\PSoC4/UART_1.c **** 
 767:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RX_INTERRUPT_ENABLED)
 768:Generated_Source\PSoC4/UART_1.c **** 
 769:Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt. */
 770:Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableRxInt();
 771:Generated_Source\PSoC4/UART_1.c **** 
 772:Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferRead = 0u;
 773:Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferWrite = 0u;
 774:Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferLoopDetect = 0u;
 775:Generated_Source\PSoC4/UART_1.c ****         UART_1_rxBufferOverflow = 0u;
 776:Generated_Source\PSoC4/UART_1.c **** 
 777:Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableRxInt();
 778:Generated_Source\PSoC4/UART_1.c **** 
 779:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_RX_INTERRUPT_ENABLED) */
 780:Generated_Source\PSoC4/UART_1.c **** 
 781:Generated_Source\PSoC4/UART_1.c ****     }
 639              		.loc 1 781 0
 640 003a BD46     		mov	sp, r7
 641 003c 03B0     		add	sp, sp, #12
 642              		@ sp needed
 643 003e 90BD     		pop	{r4, r7, pc}
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 26


 644              	.L43:
 645              		.align	2
 646              	.L42:
 647 0040 90000F40 		.word	1074725008
 648              		.cfi_endproc
 649              	.LFE13:
 650              		.size	UART_1_ClearRxBuffer, .-UART_1_ClearRxBuffer
 651              		.section	.text.UART_1_SetRxAddressMode,"ax",%progbits
 652              		.align	2
 653              		.global	UART_1_SetRxAddressMode
 654              		.code	16
 655              		.thumb_func
 656              		.type	UART_1_SetRxAddressMode, %function
 657              	UART_1_SetRxAddressMode:
 658              	.LFB14:
 782:Generated_Source\PSoC4/UART_1.c **** 
 783:Generated_Source\PSoC4/UART_1.c **** 
 784:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 785:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddressMode
 786:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 787:Generated_Source\PSoC4/UART_1.c ****     *
 788:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 789:Generated_Source\PSoC4/UART_1.c ****     *  Sets the software controlled Addressing mode used by the RX portion of the
 790:Generated_Source\PSoC4/UART_1.c ****     *  UART.
 791:Generated_Source\PSoC4/UART_1.c ****     *
 792:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 793:Generated_Source\PSoC4/UART_1.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 794:Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795:Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 796:Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 797:Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 798:Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799:Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 800:Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801:Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 802:Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_NONE - No address detection
 803:Generated_Source\PSoC4/UART_1.c ****     *
 804:Generated_Source\PSoC4/UART_1.c ****     * Return:
 805:Generated_Source\PSoC4/UART_1.c ****     *  None.
 806:Generated_Source\PSoC4/UART_1.c ****     *
 807:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 808:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressMode - the parameter stored in this variable for
 809:Generated_Source\PSoC4/UART_1.c ****     *   the farther usage in RX ISR.
 810:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressDetected - set to initial state (0).
 811:Generated_Source\PSoC4/UART_1.c ****     *
 812:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 813:Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddressMode(uint8 addressMode)
 814:Generated_Source\PSoC4/UART_1.c ****                                                         
 815:Generated_Source\PSoC4/UART_1.c ****     {
 659              		.loc 1 815 0
 660              		.cfi_startproc
 661 0000 80B5     		push	{r7, lr}
 662              		.cfi_def_cfa_offset 8
 663              		.cfi_offset 7, -8
 664              		.cfi_offset 14, -4
 665 0002 82B0     		sub	sp, sp, #8
 666              		.cfi_def_cfa_offset 16
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 27


 667 0004 00AF     		add	r7, sp, #0
 668              		.cfi_def_cfa_register 7
 669 0006 021C     		mov	r2, r0
 670 0008 FB1D     		add	r3, r7, #7
 671 000a 1A70     		strb	r2, [r3]
 816:Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXHW_ADDRESS_ENABLED)
 817:Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_CONTROL_REG_REMOVED)
 818:Generated_Source\PSoC4/UART_1.c ****                 if(0u != addressMode)
 819:Generated_Source\PSoC4/UART_1.c ****                 {
 820:Generated_Source\PSoC4/UART_1.c ****                     /* Suppress compiler warning */
 821:Generated_Source\PSoC4/UART_1.c ****                 }
 822:Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_CONTROL_REG_REMOVED */
 823:Generated_Source\PSoC4/UART_1.c ****                 uint8 tmpCtrl;
 824:Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
 825:Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
 826:Generated_Source\PSoC4/UART_1.c ****                 UART_1_CONTROL_REG = tmpCtrl;
 827:Generated_Source\PSoC4/UART_1.c **** 
 828:Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_RX_INTERRUPT_ENABLED && \
 829:Generated_Source\PSoC4/UART_1.c ****                    (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 830:Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressMode = addressMode;
 831:Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressDetected = 0u;
 832:Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
 833:Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED */
 834:Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXHW_ADDRESS_ENABLED */
 835:Generated_Source\PSoC4/UART_1.c ****             if(0u != addressMode)
 836:Generated_Source\PSoC4/UART_1.c ****             {
 837:Generated_Source\PSoC4/UART_1.c ****                 /* Suppress compiler warning */
 838:Generated_Source\PSoC4/UART_1.c ****             }
 839:Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 840:Generated_Source\PSoC4/UART_1.c ****     }
 672              		.loc 1 840 0
 673 000c BD46     		mov	sp, r7
 674 000e 02B0     		add	sp, sp, #8
 675              		@ sp needed
 676 0010 80BD     		pop	{r7, pc}
 677              		.cfi_endproc
 678              	.LFE14:
 679              		.size	UART_1_SetRxAddressMode, .-UART_1_SetRxAddressMode
 680 0012 C046     		.section	.text.UART_1_SetRxAddress1,"ax",%progbits
 681              		.align	2
 682              		.global	UART_1_SetRxAddress1
 683              		.code	16
 684              		.thumb_func
 685              		.type	UART_1_SetRxAddress1, %function
 686              	UART_1_SetRxAddress1:
 687              	.LFB15:
 841:Generated_Source\PSoC4/UART_1.c **** 
 842:Generated_Source\PSoC4/UART_1.c **** 
 843:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 844:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress1
 845:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 846:Generated_Source\PSoC4/UART_1.c ****     *
 847:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 848:Generated_Source\PSoC4/UART_1.c ****     *  Sets the first of two hardware-detectable receiver addresses.
 849:Generated_Source\PSoC4/UART_1.c ****     *
 850:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 851:Generated_Source\PSoC4/UART_1.c ****     *  address: Address #1 for hardware address detection.
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 28


 852:Generated_Source\PSoC4/UART_1.c ****     *
 853:Generated_Source\PSoC4/UART_1.c ****     * Return:
 854:Generated_Source\PSoC4/UART_1.c ****     *  None.
 855:Generated_Source\PSoC4/UART_1.c ****     *
 856:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 857:Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress1(uint8 address) 
 858:Generated_Source\PSoC4/UART_1.c ****     {
 688              		.loc 1 858 0
 689              		.cfi_startproc
 690 0000 80B5     		push	{r7, lr}
 691              		.cfi_def_cfa_offset 8
 692              		.cfi_offset 7, -8
 693              		.cfi_offset 14, -4
 694 0002 82B0     		sub	sp, sp, #8
 695              		.cfi_def_cfa_offset 16
 696 0004 00AF     		add	r7, sp, #0
 697              		.cfi_def_cfa_register 7
 698 0006 021C     		mov	r2, r0
 699 0008 FB1D     		add	r3, r7, #7
 700 000a 1A70     		strb	r2, [r3]
 859:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS1_REG = address;
 701              		.loc 1 859 0
 702 000c 034A     		ldr	r2, .L46
 703 000e FB1D     		add	r3, r7, #7
 704 0010 1B78     		ldrb	r3, [r3]
 705 0012 1370     		strb	r3, [r2]
 860:Generated_Source\PSoC4/UART_1.c ****     }
 706              		.loc 1 860 0
 707 0014 BD46     		mov	sp, r7
 708 0016 02B0     		add	sp, sp, #8
 709              		@ sp needed
 710 0018 80BD     		pop	{r7, pc}
 711              	.L47:
 712 001a C046     		.align	2
 713              	.L46:
 714 001c 20000F40 		.word	1074724896
 715              		.cfi_endproc
 716              	.LFE15:
 717              		.size	UART_1_SetRxAddress1, .-UART_1_SetRxAddress1
 718              		.section	.text.UART_1_SetRxAddress2,"ax",%progbits
 719              		.align	2
 720              		.global	UART_1_SetRxAddress2
 721              		.code	16
 722              		.thumb_func
 723              		.type	UART_1_SetRxAddress2, %function
 724              	UART_1_SetRxAddress2:
 725              	.LFB16:
 861:Generated_Source\PSoC4/UART_1.c **** 
 862:Generated_Source\PSoC4/UART_1.c **** 
 863:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 864:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress2
 865:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 866:Generated_Source\PSoC4/UART_1.c ****     *
 867:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 868:Generated_Source\PSoC4/UART_1.c ****     *  Sets the second of two hardware-detectable receiver addresses.
 869:Generated_Source\PSoC4/UART_1.c ****     *
 870:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 29


 871:Generated_Source\PSoC4/UART_1.c ****     *  address: Address #2 for hardware address detection.
 872:Generated_Source\PSoC4/UART_1.c ****     *
 873:Generated_Source\PSoC4/UART_1.c ****     * Return:
 874:Generated_Source\PSoC4/UART_1.c ****     *  None.
 875:Generated_Source\PSoC4/UART_1.c ****     *
 876:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 877:Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress2(uint8 address) 
 878:Generated_Source\PSoC4/UART_1.c ****     {
 726              		.loc 1 878 0
 727              		.cfi_startproc
 728 0000 80B5     		push	{r7, lr}
 729              		.cfi_def_cfa_offset 8
 730              		.cfi_offset 7, -8
 731              		.cfi_offset 14, -4
 732 0002 82B0     		sub	sp, sp, #8
 733              		.cfi_def_cfa_offset 16
 734 0004 00AF     		add	r7, sp, #0
 735              		.cfi_def_cfa_register 7
 736 0006 021C     		mov	r2, r0
 737 0008 FB1D     		add	r3, r7, #7
 738 000a 1A70     		strb	r2, [r3]
 879:Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS2_REG = address;
 739              		.loc 1 879 0
 740 000c 034A     		ldr	r2, .L49
 741 000e FB1D     		add	r3, r7, #7
 742 0010 1B78     		ldrb	r3, [r3]
 743 0012 1370     		strb	r3, [r2]
 880:Generated_Source\PSoC4/UART_1.c ****     }
 744              		.loc 1 880 0
 745 0014 BD46     		mov	sp, r7
 746 0016 02B0     		add	sp, sp, #8
 747              		@ sp needed
 748 0018 80BD     		pop	{r7, pc}
 749              	.L50:
 750 001a C046     		.align	2
 751              	.L49:
 752 001c 30000F40 		.word	1074724912
 753              		.cfi_endproc
 754              	.LFE16:
 755              		.size	UART_1_SetRxAddress2, .-UART_1_SetRxAddress2
 756              		.section	.text.UART_1_SetTxInterruptMode,"ax",%progbits
 757              		.align	2
 758              		.global	UART_1_SetTxInterruptMode
 759              		.code	16
 760              		.thumb_func
 761              		.type	UART_1_SetTxInterruptMode, %function
 762              	UART_1_SetTxInterruptMode:
 763              	.LFB17:
 881:Generated_Source\PSoC4/UART_1.c **** 
 882:Generated_Source\PSoC4/UART_1.c **** #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 883:Generated_Source\PSoC4/UART_1.c **** 
 884:Generated_Source\PSoC4/UART_1.c **** 
 885:Generated_Source\PSoC4/UART_1.c **** #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 886:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 887:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxInterruptMode
 888:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 889:Generated_Source\PSoC4/UART_1.c ****     *
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 30


 890:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 891:Generated_Source\PSoC4/UART_1.c ****     *  Configures the TX interrupt sources to be enabled, but does not enable the
 892:Generated_Source\PSoC4/UART_1.c ****     *  interrupt.
 893:Generated_Source\PSoC4/UART_1.c ****     *
 894:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 895:Generated_Source\PSoC4/UART_1.c ****     *  intSrc: Bit field containing the TX interrupt sources to enable
 896:Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_COMPLETE        Interrupt on TX byte complete
 897:Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898:Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899:Generated_Source\PSoC4/UART_1.c ****     *   UART_1_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900:Generated_Source\PSoC4/UART_1.c ****     *
 901:Generated_Source\PSoC4/UART_1.c ****     * Return:
 902:Generated_Source\PSoC4/UART_1.c ****     *  None.
 903:Generated_Source\PSoC4/UART_1.c ****     *
 904:Generated_Source\PSoC4/UART_1.c ****     * Theory:
 905:Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 906:Generated_Source\PSoC4/UART_1.c ****     *
 907:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 908:Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxInterruptMode(uint8 intSrc) 
 909:Generated_Source\PSoC4/UART_1.c ****     {
 764              		.loc 1 909 0
 765              		.cfi_startproc
 766 0000 80B5     		push	{r7, lr}
 767              		.cfi_def_cfa_offset 8
 768              		.cfi_offset 7, -8
 769              		.cfi_offset 14, -4
 770 0002 82B0     		sub	sp, sp, #8
 771              		.cfi_def_cfa_offset 16
 772 0004 00AF     		add	r7, sp, #0
 773              		.cfi_def_cfa_register 7
 774 0006 021C     		mov	r2, r0
 775 0008 FB1D     		add	r3, r7, #7
 776 000a 1A70     		strb	r2, [r3]
 910:Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_MASK_REG = intSrc;
 777              		.loc 1 910 0
 778 000c 034A     		ldr	r2, .L52
 779 000e FB1D     		add	r3, r7, #7
 780 0010 1B78     		ldrb	r3, [r3]
 781 0012 1370     		strb	r3, [r2]
 911:Generated_Source\PSoC4/UART_1.c ****     }
 782              		.loc 1 911 0
 783 0014 BD46     		mov	sp, r7
 784 0016 02B0     		add	sp, sp, #8
 785              		@ sp needed
 786 0018 80BD     		pop	{r7, pc}
 787              	.L53:
 788 001a C046     		.align	2
 789              	.L52:
 790 001c 82000F40 		.word	1074724994
 791              		.cfi_endproc
 792              	.LFE17:
 793              		.size	UART_1_SetTxInterruptMode, .-UART_1_SetTxInterruptMode
 794              		.section	.text.UART_1_WriteTxData,"ax",%progbits
 795              		.align	2
 796              		.global	UART_1_WriteTxData
 797              		.code	16
 798              		.thumb_func
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 31


 799              		.type	UART_1_WriteTxData, %function
 800              	UART_1_WriteTxData:
 801              	.LFB18:
 912:Generated_Source\PSoC4/UART_1.c **** 
 913:Generated_Source\PSoC4/UART_1.c **** 
 914:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 915:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_WriteTxData
 916:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 917:Generated_Source\PSoC4/UART_1.c ****     *
 918:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 919:Generated_Source\PSoC4/UART_1.c ****     *  Places a byte of data into the transmit buffer to be sent when the bus is
 920:Generated_Source\PSoC4/UART_1.c ****     *  available without checking the TX status register. You must check status
 921:Generated_Source\PSoC4/UART_1.c ****     *  separately.
 922:Generated_Source\PSoC4/UART_1.c ****     *
 923:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 924:Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: data byte
 925:Generated_Source\PSoC4/UART_1.c ****     *
 926:Generated_Source\PSoC4/UART_1.c ****     * Return:
 927:Generated_Source\PSoC4/UART_1.c ****     * None.
 928:Generated_Source\PSoC4/UART_1.c ****     *
 929:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 930:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 931:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 932:Generated_Source\PSoC4/UART_1.c ****     *    incremented after each byte saved to buffer.
 933:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 934:Generated_Source\PSoC4/UART_1.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 935:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
 936:Generated_Source\PSoC4/UART_1.c ****     *    initialized.
 937:Generated_Source\PSoC4/UART_1.c ****     *
 938:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 939:Generated_Source\PSoC4/UART_1.c ****     *  No.
 940:Generated_Source\PSoC4/UART_1.c ****     *
 941:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 942:Generated_Source\PSoC4/UART_1.c ****     void UART_1_WriteTxData(uint8 txDataByte) 
 943:Generated_Source\PSoC4/UART_1.c ****     {
 802              		.loc 1 943 0
 803              		.cfi_startproc
 804 0000 80B5     		push	{r7, lr}
 805              		.cfi_def_cfa_offset 8
 806              		.cfi_offset 7, -8
 807              		.cfi_offset 14, -4
 808 0002 82B0     		sub	sp, sp, #8
 809              		.cfi_def_cfa_offset 16
 810 0004 00AF     		add	r7, sp, #0
 811              		.cfi_def_cfa_register 7
 812 0006 021C     		mov	r2, r0
 813 0008 FB1D     		add	r3, r7, #7
 814 000a 1A70     		strb	r2, [r3]
 944:Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
 945:Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 815              		.loc 1 945 0
 816 000c 054B     		ldr	r3, .L56
 817 000e 1B78     		ldrb	r3, [r3]
 818 0010 002B     		cmp	r3, #0
 819 0012 03D0     		beq	.L54
 946:Generated_Source\PSoC4/UART_1.c ****         {
 947:Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_TX_INTERRUPT_ENABLED)
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 32


 948:Generated_Source\PSoC4/UART_1.c **** 
 949:Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 950:Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
 951:Generated_Source\PSoC4/UART_1.c **** 
 952:Generated_Source\PSoC4/UART_1.c ****             if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
 953:Generated_Source\PSoC4/UART_1.c ****                 ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
 954:Generated_Source\PSoC4/UART_1.c ****             {
 955:Generated_Source\PSoC4/UART_1.c ****                 /* Add directly to the FIFO. */
 956:Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 957:Generated_Source\PSoC4/UART_1.c ****             }
 958:Generated_Source\PSoC4/UART_1.c ****             else
 959:Generated_Source\PSoC4/UART_1.c ****             {
 960:Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_txBufferWrite >= UART_1_TX_BUFFER_SIZE)
 961:Generated_Source\PSoC4/UART_1.c ****                 {
 962:Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite = 0u;
 963:Generated_Source\PSoC4/UART_1.c ****                 }
 964:Generated_Source\PSoC4/UART_1.c **** 
 965:Generated_Source\PSoC4/UART_1.c ****                 UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
 966:Generated_Source\PSoC4/UART_1.c **** 
 967:Generated_Source\PSoC4/UART_1.c ****                 /* Add to the software buffer. */
 968:Generated_Source\PSoC4/UART_1.c ****                 UART_1_txBufferWrite++;
 969:Generated_Source\PSoC4/UART_1.c ****             }
 970:Generated_Source\PSoC4/UART_1.c **** 
 971:Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
 972:Generated_Source\PSoC4/UART_1.c **** 
 973:Generated_Source\PSoC4/UART_1.c ****         #else
 974:Generated_Source\PSoC4/UART_1.c **** 
 975:Generated_Source\PSoC4/UART_1.c ****             /* Add directly to the FIFO. */
 976:Generated_Source\PSoC4/UART_1.c ****             UART_1_TXDATA_REG = txDataByte;
 820              		.loc 1 976 0
 821 0014 044A     		ldr	r2, .L56+4
 822 0016 FB1D     		add	r3, r7, #7
 823 0018 1B78     		ldrb	r3, [r3]
 824 001a 1370     		strb	r3, [r2]
 825              	.L54:
 977:Generated_Source\PSoC4/UART_1.c **** 
 978:Generated_Source\PSoC4/UART_1.c ****         #endif /*(UART_1_TX_INTERRUPT_ENABLED) */
 979:Generated_Source\PSoC4/UART_1.c ****         }
 980:Generated_Source\PSoC4/UART_1.c ****     }
 826              		.loc 1 980 0
 827 001c BD46     		mov	sp, r7
 828 001e 02B0     		add	sp, sp, #8
 829              		@ sp needed
 830 0020 80BD     		pop	{r7, pc}
 831              	.L57:
 832 0022 C046     		.align	2
 833              	.L56:
 834 0024 00000000 		.word	UART_1_initVar
 835 0028 42000F40 		.word	1074724930
 836              		.cfi_endproc
 837              	.LFE18:
 838              		.size	UART_1_WriteTxData, .-UART_1_WriteTxData
 839              		.section	.text.UART_1_ReadTxStatus,"ax",%progbits
 840              		.align	2
 841              		.global	UART_1_ReadTxStatus
 842              		.code	16
 843              		.thumb_func
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 33


 844              		.type	UART_1_ReadTxStatus, %function
 845              	UART_1_ReadTxStatus:
 846              	.LFB19:
 981:Generated_Source\PSoC4/UART_1.c **** 
 982:Generated_Source\PSoC4/UART_1.c **** 
 983:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 984:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadTxStatus
 985:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 986:Generated_Source\PSoC4/UART_1.c ****     *
 987:Generated_Source\PSoC4/UART_1.c ****     * Summary:
 988:Generated_Source\PSoC4/UART_1.c ****     *  Reads the status register for the TX portion of the UART.
 989:Generated_Source\PSoC4/UART_1.c ****     *
 990:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 991:Generated_Source\PSoC4/UART_1.c ****     *  None.
 992:Generated_Source\PSoC4/UART_1.c ****     *
 993:Generated_Source\PSoC4/UART_1.c ****     * Return:
 994:Generated_Source\PSoC4/UART_1.c ****     *  Contents of the status register
 995:Generated_Source\PSoC4/UART_1.c ****     *
 996:Generated_Source\PSoC4/UART_1.c ****     * Theory:
 997:Generated_Source\PSoC4/UART_1.c ****     *  This function reads the TX status register, which is cleared on read.
 998:Generated_Source\PSoC4/UART_1.c ****     *  It is up to the user to handle all bits in this return value accordingly,
 999:Generated_Source\PSoC4/UART_1.c ****     *  even if the bit was not enabled as an interrupt source the event happened
1000:Generated_Source\PSoC4/UART_1.c ****     *  and must be handled accordingly.
1001:Generated_Source\PSoC4/UART_1.c ****     *
1002:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1003:Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadTxStatus(void) 
1004:Generated_Source\PSoC4/UART_1.c ****     {
 847              		.loc 1 1004 0
 848              		.cfi_startproc
 849 0000 80B5     		push	{r7, lr}
 850              		.cfi_def_cfa_offset 8
 851              		.cfi_offset 7, -8
 852              		.cfi_offset 14, -4
 853 0002 00AF     		add	r7, sp, #0
 854              		.cfi_def_cfa_register 7
1005:Generated_Source\PSoC4/UART_1.c ****         return(UART_1_TXSTATUS_REG);
 855              		.loc 1 1005 0
 856 0004 024B     		ldr	r3, .L60
 857 0006 1B78     		ldrb	r3, [r3]
 858 0008 DBB2     		uxtb	r3, r3
1006:Generated_Source\PSoC4/UART_1.c ****     }
 859              		.loc 1 1006 0
 860 000a 181C     		mov	r0, r3
 861 000c BD46     		mov	sp, r7
 862              		@ sp needed
 863 000e 80BD     		pop	{r7, pc}
 864              	.L61:
 865              		.align	2
 866              	.L60:
 867 0010 62000F40 		.word	1074724962
 868              		.cfi_endproc
 869              	.LFE19:
 870              		.size	UART_1_ReadTxStatus, .-UART_1_ReadTxStatus
 871              		.section	.text.UART_1_PutChar,"ax",%progbits
 872              		.align	2
 873              		.global	UART_1_PutChar
 874              		.code	16
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 34


 875              		.thumb_func
 876              		.type	UART_1_PutChar, %function
 877              	UART_1_PutChar:
 878              	.LFB20:
1007:Generated_Source\PSoC4/UART_1.c **** 
1008:Generated_Source\PSoC4/UART_1.c **** 
1009:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1010:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutChar
1011:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1012:Generated_Source\PSoC4/UART_1.c ****     *
1013:Generated_Source\PSoC4/UART_1.c ****     * Summary:
1014:Generated_Source\PSoC4/UART_1.c ****     *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015:Generated_Source\PSoC4/UART_1.c ****     *  available. This is a blocking API that waits until the TX buffer has room to
1016:Generated_Source\PSoC4/UART_1.c ****     *  hold the data.
1017:Generated_Source\PSoC4/UART_1.c ****     *
1018:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1019:Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: Byte containing the data to transmit
1020:Generated_Source\PSoC4/UART_1.c ****     *
1021:Generated_Source\PSoC4/UART_1.c ****     * Return:
1022:Generated_Source\PSoC4/UART_1.c ****     *  None.
1023:Generated_Source\PSoC4/UART_1.c ****     *
1024:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1025:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1026:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1027:Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1028:Generated_Source\PSoC4/UART_1.c ****     *     saved to buffer.
1029:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1030:Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer.
1031:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1032:Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1033:Generated_Source\PSoC4/UART_1.c ****     *
1034:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1035:Generated_Source\PSoC4/UART_1.c ****     *  No.
1036:Generated_Source\PSoC4/UART_1.c ****     *
1037:Generated_Source\PSoC4/UART_1.c ****     * Theory:
1038:Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to transmit any byte of data in a single transfer
1039:Generated_Source\PSoC4/UART_1.c ****     *
1040:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1041:Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutChar(uint8 txDataByte) 
1042:Generated_Source\PSoC4/UART_1.c ****     {
 879              		.loc 1 1042 0
 880              		.cfi_startproc
 881 0000 80B5     		push	{r7, lr}
 882              		.cfi_def_cfa_offset 8
 883              		.cfi_offset 7, -8
 884              		.cfi_offset 14, -4
 885 0002 82B0     		sub	sp, sp, #8
 886              		.cfi_def_cfa_offset 16
 887 0004 00AF     		add	r7, sp, #0
 888              		.cfi_def_cfa_register 7
 889 0006 021C     		mov	r2, r0
 890 0008 FB1D     		add	r3, r7, #7
 891 000a 1A70     		strb	r2, [r3]
1043:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1044:Generated_Source\PSoC4/UART_1.c ****         /* The temporary output pointer is used since it takes two instructions
1045:Generated_Source\PSoC4/UART_1.c ****         *  to increment with a wrap, and we can't risk doing that with the real
1046:Generated_Source\PSoC4/UART_1.c ****         *  pointer and getting an interrupt in between instructions.
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 35


1047:Generated_Source\PSoC4/UART_1.c ****         */
1048:Generated_Source\PSoC4/UART_1.c ****         uint8 locTxBufferWrite;
1049:Generated_Source\PSoC4/UART_1.c ****         uint8 locTxBufferRead;
1050:Generated_Source\PSoC4/UART_1.c **** 
1051:Generated_Source\PSoC4/UART_1.c ****         do
1052:Generated_Source\PSoC4/UART_1.c ****         { /* Block if software buffer is full, so we don't overwrite. */
1053:Generated_Source\PSoC4/UART_1.c **** 
1054:Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1055:Generated_Source\PSoC4/UART_1.c ****             /* Disable TX interrupt to protect variables from modification */
1056:Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
1057:Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
1058:Generated_Source\PSoC4/UART_1.c **** 
1059:Generated_Source\PSoC4/UART_1.c ****             locTxBufferWrite = UART_1_txBufferWrite;
1060:Generated_Source\PSoC4/UART_1.c ****             locTxBufferRead  = UART_1_txBufferRead;
1061:Generated_Source\PSoC4/UART_1.c **** 
1062:Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1063:Generated_Source\PSoC4/UART_1.c ****             /* Enable interrupt to continue transmission */
1064:Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
1065:Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
1066:Generated_Source\PSoC4/UART_1.c ****         }
1067:Generated_Source\PSoC4/UART_1.c ****         while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) 
1068:Generated_Source\PSoC4/UART_1.c ****                                 ((locTxBufferWrite - locTxBufferRead) ==
1069:Generated_Source\PSoC4/UART_1.c ****                                 (uint8)(UART_1_TX_BUFFER_SIZE - 1u)) );
1070:Generated_Source\PSoC4/UART_1.c **** 
1071:Generated_Source\PSoC4/UART_1.c ****         if( (locTxBufferRead == locTxBufferWrite) &&
1072:Generated_Source\PSoC4/UART_1.c ****             ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1073:Generated_Source\PSoC4/UART_1.c ****         {
1074:Generated_Source\PSoC4/UART_1.c ****             /* Add directly to the FIFO */
1075:Generated_Source\PSoC4/UART_1.c ****             UART_1_TXDATA_REG = txDataByte;
1076:Generated_Source\PSoC4/UART_1.c ****         }
1077:Generated_Source\PSoC4/UART_1.c ****         else
1078:Generated_Source\PSoC4/UART_1.c ****         {
1079:Generated_Source\PSoC4/UART_1.c ****             if(locTxBufferWrite >= UART_1_TX_BUFFER_SIZE)
1080:Generated_Source\PSoC4/UART_1.c ****             {
1081:Generated_Source\PSoC4/UART_1.c ****                 locTxBufferWrite = 0u;
1082:Generated_Source\PSoC4/UART_1.c ****             }
1083:Generated_Source\PSoC4/UART_1.c ****             /* Add to the software buffer. */
1084:Generated_Source\PSoC4/UART_1.c ****             UART_1_txBuffer[locTxBufferWrite] = txDataByte;
1085:Generated_Source\PSoC4/UART_1.c ****             locTxBufferWrite++;
1086:Generated_Source\PSoC4/UART_1.c **** 
1087:Generated_Source\PSoC4/UART_1.c ****             /* Finally, update the real output pointer */
1088:Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1089:Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
1090:Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
1091:Generated_Source\PSoC4/UART_1.c **** 
1092:Generated_Source\PSoC4/UART_1.c ****             UART_1_txBufferWrite = locTxBufferWrite;
1093:Generated_Source\PSoC4/UART_1.c **** 
1094:Generated_Source\PSoC4/UART_1.c ****         #if ((UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1095:Generated_Source\PSoC4/UART_1.c ****             UART_1_EnableTxInt();
1096:Generated_Source\PSoC4/UART_1.c ****         #endif /* (UART_1_TX_BUFFER_SIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3) */
1097:Generated_Source\PSoC4/UART_1.c **** 
1098:Generated_Source\PSoC4/UART_1.c ****             if(0u != (UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_EMPTY))
1099:Generated_Source\PSoC4/UART_1.c ****             {
1100:Generated_Source\PSoC4/UART_1.c ****                 /* Trigger TX interrupt to send software buffer */
1101:Generated_Source\PSoC4/UART_1.c ****                 UART_1_SetPendingTxInt();
1102:Generated_Source\PSoC4/UART_1.c ****             }
1103:Generated_Source\PSoC4/UART_1.c ****         }
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 36


1104:Generated_Source\PSoC4/UART_1.c **** 
1105:Generated_Source\PSoC4/UART_1.c ****     #else
1106:Generated_Source\PSoC4/UART_1.c **** 
1107:Generated_Source\PSoC4/UART_1.c ****         while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
 892              		.loc 1 1107 0
 893 000c C046     		mov	r8, r8
 894              	.L63:
 895              		.loc 1 1107 0 is_stmt 0 discriminator 1
 896 000e 074B     		ldr	r3, .L64
 897 0010 1B78     		ldrb	r3, [r3]
 898 0012 DBB2     		uxtb	r3, r3
 899 0014 1A1C     		mov	r2, r3
 900 0016 0423     		mov	r3, #4
 901 0018 1340     		and	r3, r2
 902 001a F8D1     		bne	.L63
1108:Generated_Source\PSoC4/UART_1.c ****         {
1109:Generated_Source\PSoC4/UART_1.c ****             /* Wait for room in the FIFO */
1110:Generated_Source\PSoC4/UART_1.c ****         }
1111:Generated_Source\PSoC4/UART_1.c **** 
1112:Generated_Source\PSoC4/UART_1.c ****         /* Add directly to the FIFO */
1113:Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_REG = txDataByte;
 903              		.loc 1 1113 0 is_stmt 1
 904 001c 044A     		ldr	r2, .L64+4
 905 001e FB1D     		add	r3, r7, #7
 906 0020 1B78     		ldrb	r3, [r3]
 907 0022 1370     		strb	r3, [r2]
1114:Generated_Source\PSoC4/UART_1.c **** 
1115:Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_TX_INTERRUPT_ENABLED */
1116:Generated_Source\PSoC4/UART_1.c ****     }
 908              		.loc 1 1116 0
 909 0024 BD46     		mov	sp, r7
 910 0026 02B0     		add	sp, sp, #8
 911              		@ sp needed
 912 0028 80BD     		pop	{r7, pc}
 913              	.L65:
 914 002a C046     		.align	2
 915              	.L64:
 916 002c 62000F40 		.word	1074724962
 917 0030 42000F40 		.word	1074724930
 918              		.cfi_endproc
 919              	.LFE20:
 920              		.size	UART_1_PutChar, .-UART_1_PutChar
 921              		.section	.text.UART_1_PutString,"ax",%progbits
 922              		.align	2
 923              		.global	UART_1_PutString
 924              		.code	16
 925              		.thumb_func
 926              		.type	UART_1_PutString, %function
 927              	UART_1_PutString:
 928              	.LFB21:
1117:Generated_Source\PSoC4/UART_1.c **** 
1118:Generated_Source\PSoC4/UART_1.c **** 
1119:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1120:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutString
1121:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1122:Generated_Source\PSoC4/UART_1.c ****     *
1123:Generated_Source\PSoC4/UART_1.c ****     * Summary:
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 37


1124:Generated_Source\PSoC4/UART_1.c ****     *  Sends a NULL terminated string to the TX buffer for transmission.
1125:Generated_Source\PSoC4/UART_1.c ****     *
1126:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1127:Generated_Source\PSoC4/UART_1.c ****     *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128:Generated_Source\PSoC4/UART_1.c ****     *
1129:Generated_Source\PSoC4/UART_1.c ****     * Return:
1130:Generated_Source\PSoC4/UART_1.c ****     *  None.
1131:Generated_Source\PSoC4/UART_1.c ****     *
1132:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1133:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1134:Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1135:Generated_Source\PSoC4/UART_1.c ****     *
1136:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1137:Generated_Source\PSoC4/UART_1.c ****     *  No.
1138:Generated_Source\PSoC4/UART_1.c ****     *
1139:Generated_Source\PSoC4/UART_1.c ****     * Theory:
1140:Generated_Source\PSoC4/UART_1.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1141:Generated_Source\PSoC4/UART_1.c ****     *  function blocks until the last character of the string is loaded into the
1142:Generated_Source\PSoC4/UART_1.c ****     *  TX buffer.
1143:Generated_Source\PSoC4/UART_1.c ****     *
1144:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1145:Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutString(const char8 string[]) 
1146:Generated_Source\PSoC4/UART_1.c ****     {
 929              		.loc 1 1146 0
 930              		.cfi_startproc
 931 0000 80B5     		push	{r7, lr}
 932              		.cfi_def_cfa_offset 8
 933              		.cfi_offset 7, -8
 934              		.cfi_offset 14, -4
 935 0002 84B0     		sub	sp, sp, #16
 936              		.cfi_def_cfa_offset 24
 937 0004 00AF     		add	r7, sp, #0
 938              		.cfi_def_cfa_register 7
 939 0006 7860     		str	r0, [r7, #4]
1147:Generated_Source\PSoC4/UART_1.c ****         uint16 bufIndex = 0u;
 940              		.loc 1 1147 0
 941 0008 0E23     		mov	r3, #14
 942 000a FB18     		add	r3, r7, r3
 943 000c 0022     		mov	r2, #0
 944 000e 1A80     		strh	r2, [r3]
1148:Generated_Source\PSoC4/UART_1.c **** 
1149:Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function */
1150:Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 945              		.loc 1 1150 0
 946 0010 0F4B     		ldr	r3, .L70
 947 0012 1B78     		ldrb	r3, [r3]
 948 0014 002B     		cmp	r3, #0
 949 0016 18D0     		beq	.L66
1151:Generated_Source\PSoC4/UART_1.c ****         {
1152:Generated_Source\PSoC4/UART_1.c ****             /* This is a blocking function, it will not exit until all data is sent */
1153:Generated_Source\PSoC4/UART_1.c ****             while(string[bufIndex] != (char8) 0)
 950              		.loc 1 1153 0
 951 0018 0FE0     		b	.L68
 952              	.L69:
1154:Generated_Source\PSoC4/UART_1.c ****             {
1155:Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar((uint8)string[bufIndex]);
 953              		.loc 1 1155 0
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 38


 954 001a 0E23     		mov	r3, #14
 955 001c FB18     		add	r3, r7, r3
 956 001e 1B88     		ldrh	r3, [r3]
 957 0020 7A68     		ldr	r2, [r7, #4]
 958 0022 D318     		add	r3, r2, r3
 959 0024 1B78     		ldrb	r3, [r3]
 960 0026 181C     		mov	r0, r3
 961 0028 FFF7FEFF 		bl	UART_1_PutChar
1156:Generated_Source\PSoC4/UART_1.c ****                 bufIndex++;
 962              		.loc 1 1156 0
 963 002c 0E23     		mov	r3, #14
 964 002e FB18     		add	r3, r7, r3
 965 0030 1A88     		ldrh	r2, [r3]
 966 0032 0E23     		mov	r3, #14
 967 0034 FB18     		add	r3, r7, r3
 968 0036 0132     		add	r2, r2, #1
 969 0038 1A80     		strh	r2, [r3]
 970              	.L68:
1153:Generated_Source\PSoC4/UART_1.c ****             {
 971              		.loc 1 1153 0
 972 003a 0E23     		mov	r3, #14
 973 003c FB18     		add	r3, r7, r3
 974 003e 1B88     		ldrh	r3, [r3]
 975 0040 7A68     		ldr	r2, [r7, #4]
 976 0042 D318     		add	r3, r2, r3
 977 0044 1B78     		ldrb	r3, [r3]
 978 0046 002B     		cmp	r3, #0
 979 0048 E7D1     		bne	.L69
 980              	.L66:
1157:Generated_Source\PSoC4/UART_1.c ****             }
1158:Generated_Source\PSoC4/UART_1.c ****         }
1159:Generated_Source\PSoC4/UART_1.c ****     }
 981              		.loc 1 1159 0
 982 004a BD46     		mov	sp, r7
 983 004c 04B0     		add	sp, sp, #16
 984              		@ sp needed
 985 004e 80BD     		pop	{r7, pc}
 986              	.L71:
 987              		.align	2
 988              	.L70:
 989 0050 00000000 		.word	UART_1_initVar
 990              		.cfi_endproc
 991              	.LFE21:
 992              		.size	UART_1_PutString, .-UART_1_PutString
 993              		.section	.text.UART_1_PutArray,"ax",%progbits
 994              		.align	2
 995              		.global	UART_1_PutArray
 996              		.code	16
 997              		.thumb_func
 998              		.type	UART_1_PutArray, %function
 999              	UART_1_PutArray:
 1000              	.LFB22:
1160:Generated_Source\PSoC4/UART_1.c **** 
1161:Generated_Source\PSoC4/UART_1.c **** 
1162:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1163:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutArray
1164:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 39


1165:Generated_Source\PSoC4/UART_1.c ****     *
1166:Generated_Source\PSoC4/UART_1.c ****     * Summary:
1167:Generated_Source\PSoC4/UART_1.c ****     *  Places N bytes of data from a memory array into the TX buffer for
1168:Generated_Source\PSoC4/UART_1.c ****     *  transmission.
1169:Generated_Source\PSoC4/UART_1.c ****     *
1170:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1171:Generated_Source\PSoC4/UART_1.c ****     *  string[]: Address of the memory array residing in RAM or ROM.
1172:Generated_Source\PSoC4/UART_1.c ****     *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173:Generated_Source\PSoC4/UART_1.c ****     *             Size parameter.
1174:Generated_Source\PSoC4/UART_1.c ****     *
1175:Generated_Source\PSoC4/UART_1.c ****     * Return:
1176:Generated_Source\PSoC4/UART_1.c ****     *  None.
1177:Generated_Source\PSoC4/UART_1.c ****     *
1178:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1179:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1180:Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1181:Generated_Source\PSoC4/UART_1.c ****     *
1182:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1183:Generated_Source\PSoC4/UART_1.c ****     *  No.
1184:Generated_Source\PSoC4/UART_1.c ****     *
1185:Generated_Source\PSoC4/UART_1.c ****     * Theory:
1186:Generated_Source\PSoC4/UART_1.c ****     *  If there is not enough memory in the TX buffer for the entire string, this
1187:Generated_Source\PSoC4/UART_1.c ****     *  function blocks until the last character of the string is loaded into the
1188:Generated_Source\PSoC4/UART_1.c ****     *  TX buffer.
1189:Generated_Source\PSoC4/UART_1.c ****     *
1190:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1191:Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1192:Generated_Source\PSoC4/UART_1.c ****                                                                     
1193:Generated_Source\PSoC4/UART_1.c ****     {
 1001              		.loc 1 1193 0
 1002              		.cfi_startproc
 1003 0000 80B5     		push	{r7, lr}
 1004              		.cfi_def_cfa_offset 8
 1005              		.cfi_offset 7, -8
 1006              		.cfi_offset 14, -4
 1007 0002 84B0     		sub	sp, sp, #16
 1008              		.cfi_def_cfa_offset 24
 1009 0004 00AF     		add	r7, sp, #0
 1010              		.cfi_def_cfa_register 7
 1011 0006 7860     		str	r0, [r7, #4]
 1012 0008 0A1C     		mov	r2, r1
 1013 000a FB1C     		add	r3, r7, #3
 1014 000c 1A70     		strb	r2, [r3]
1194:Generated_Source\PSoC4/UART_1.c ****         uint8 bufIndex = 0u;
 1015              		.loc 1 1194 0
 1016 000e 0F23     		mov	r3, #15
 1017 0010 FB18     		add	r3, r7, r3
 1018 0012 0022     		mov	r2, #0
 1019 0014 1A70     		strb	r2, [r3]
1195:Generated_Source\PSoC4/UART_1.c **** 
1196:Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function */
1197:Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1020              		.loc 1 1197 0
 1021 0016 0F4B     		ldr	r3, .L76
 1022 0018 1B78     		ldrb	r3, [r3]
 1023 001a 002B     		cmp	r3, #0
 1024 001c 17D0     		beq	.L72
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 40


1198:Generated_Source\PSoC4/UART_1.c ****         {
1199:Generated_Source\PSoC4/UART_1.c ****             while(bufIndex < byteCount)
 1025              		.loc 1 1199 0
 1026 001e 0FE0     		b	.L74
 1027              	.L75:
1200:Generated_Source\PSoC4/UART_1.c ****             {
1201:Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar(string[bufIndex]);
 1028              		.loc 1 1201 0
 1029 0020 0F23     		mov	r3, #15
 1030 0022 FB18     		add	r3, r7, r3
 1031 0024 1B78     		ldrb	r3, [r3]
 1032 0026 7A68     		ldr	r2, [r7, #4]
 1033 0028 D318     		add	r3, r2, r3
 1034 002a 1B78     		ldrb	r3, [r3]
 1035 002c 181C     		mov	r0, r3
 1036 002e FFF7FEFF 		bl	UART_1_PutChar
1202:Generated_Source\PSoC4/UART_1.c ****                 bufIndex++;
 1037              		.loc 1 1202 0
 1038 0032 0F23     		mov	r3, #15
 1039 0034 FB18     		add	r3, r7, r3
 1040 0036 1A78     		ldrb	r2, [r3]
 1041 0038 0F23     		mov	r3, #15
 1042 003a FB18     		add	r3, r7, r3
 1043 003c 0132     		add	r2, r2, #1
 1044 003e 1A70     		strb	r2, [r3]
 1045              	.L74:
1199:Generated_Source\PSoC4/UART_1.c ****             {
 1046              		.loc 1 1199 0
 1047 0040 0F23     		mov	r3, #15
 1048 0042 FA18     		add	r2, r7, r3
 1049 0044 FB1C     		add	r3, r7, #3
 1050 0046 1278     		ldrb	r2, [r2]
 1051 0048 1B78     		ldrb	r3, [r3]
 1052 004a 9A42     		cmp	r2, r3
 1053 004c E8D3     		bcc	.L75
 1054              	.L72:
1203:Generated_Source\PSoC4/UART_1.c ****             }
1204:Generated_Source\PSoC4/UART_1.c ****         }
1205:Generated_Source\PSoC4/UART_1.c ****     }
 1055              		.loc 1 1205 0
 1056 004e BD46     		mov	sp, r7
 1057 0050 04B0     		add	sp, sp, #16
 1058              		@ sp needed
 1059 0052 80BD     		pop	{r7, pc}
 1060              	.L77:
 1061              		.align	2
 1062              	.L76:
 1063 0054 00000000 		.word	UART_1_initVar
 1064              		.cfi_endproc
 1065              	.LFE22:
 1066              		.size	UART_1_PutArray, .-UART_1_PutArray
 1067              		.section	.text.UART_1_PutCRLF,"ax",%progbits
 1068              		.align	2
 1069              		.global	UART_1_PutCRLF
 1070              		.code	16
 1071              		.thumb_func
 1072              		.type	UART_1_PutCRLF, %function
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 41


 1073              	UART_1_PutCRLF:
 1074              	.LFB23:
1206:Generated_Source\PSoC4/UART_1.c **** 
1207:Generated_Source\PSoC4/UART_1.c **** 
1208:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1209:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutCRLF
1210:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1211:Generated_Source\PSoC4/UART_1.c ****     *
1212:Generated_Source\PSoC4/UART_1.c ****     * Summary:
1213:Generated_Source\PSoC4/UART_1.c ****     *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214:Generated_Source\PSoC4/UART_1.c ****     *  (0x0A) to the transmit buffer.
1215:Generated_Source\PSoC4/UART_1.c ****     *
1216:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1217:Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218:Generated_Source\PSoC4/UART_1.c ****     *
1219:Generated_Source\PSoC4/UART_1.c ****     * Return:
1220:Generated_Source\PSoC4/UART_1.c ****     *  None.
1221:Generated_Source\PSoC4/UART_1.c ****     *
1222:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1223:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1224:Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1225:Generated_Source\PSoC4/UART_1.c ****     *
1226:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1227:Generated_Source\PSoC4/UART_1.c ****     *  No.
1228:Generated_Source\PSoC4/UART_1.c ****     *
1229:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1230:Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutCRLF(uint8 txDataByte) 
1231:Generated_Source\PSoC4/UART_1.c ****     {
 1075              		.loc 1 1231 0
 1076              		.cfi_startproc
 1077 0000 80B5     		push	{r7, lr}
 1078              		.cfi_def_cfa_offset 8
 1079              		.cfi_offset 7, -8
 1080              		.cfi_offset 14, -4
 1081 0002 82B0     		sub	sp, sp, #8
 1082              		.cfi_def_cfa_offset 16
 1083 0004 00AF     		add	r7, sp, #0
 1084              		.cfi_def_cfa_register 7
 1085 0006 021C     		mov	r2, r0
 1086 0008 FB1D     		add	r3, r7, #7
 1087 000a 1A70     		strb	r2, [r3]
1232:Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function */
1233:Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1088              		.loc 1 1233 0
 1089 000c 084B     		ldr	r3, .L80
 1090 000e 1B78     		ldrb	r3, [r3]
 1091 0010 002B     		cmp	r3, #0
 1092 0012 0AD0     		beq	.L78
1234:Generated_Source\PSoC4/UART_1.c ****         {
1235:Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(txDataByte);
 1093              		.loc 1 1235 0
 1094 0014 FB1D     		add	r3, r7, #7
 1095 0016 1B78     		ldrb	r3, [r3]
 1096 0018 181C     		mov	r0, r3
 1097 001a FFF7FEFF 		bl	UART_1_PutChar
1236:Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Du);
 1098              		.loc 1 1236 0
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 42


 1099 001e 0D20     		mov	r0, #13
 1100 0020 FFF7FEFF 		bl	UART_1_PutChar
1237:Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Au);
 1101              		.loc 1 1237 0
 1102 0024 0A20     		mov	r0, #10
 1103 0026 FFF7FEFF 		bl	UART_1_PutChar
 1104              	.L78:
1238:Generated_Source\PSoC4/UART_1.c ****         }
1239:Generated_Source\PSoC4/UART_1.c ****     }
 1105              		.loc 1 1239 0
 1106 002a BD46     		mov	sp, r7
 1107 002c 02B0     		add	sp, sp, #8
 1108              		@ sp needed
 1109 002e 80BD     		pop	{r7, pc}
 1110              	.L81:
 1111              		.align	2
 1112              	.L80:
 1113 0030 00000000 		.word	UART_1_initVar
 1114              		.cfi_endproc
 1115              	.LFE23:
 1116              		.size	UART_1_PutCRLF, .-UART_1_PutCRLF
 1117              		.section	.text.UART_1_GetTxBufferSize,"ax",%progbits
 1118              		.align	2
 1119              		.global	UART_1_GetTxBufferSize
 1120              		.code	16
 1121              		.thumb_func
 1122              		.type	UART_1_GetTxBufferSize, %function
 1123              	UART_1_GetTxBufferSize:
 1124              	.LFB24:
1240:Generated_Source\PSoC4/UART_1.c **** 
1241:Generated_Source\PSoC4/UART_1.c **** 
1242:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1243:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetTxBufferSize
1244:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1245:Generated_Source\PSoC4/UART_1.c ****     *
1246:Generated_Source\PSoC4/UART_1.c ****     * Summary:
1247:Generated_Source\PSoC4/UART_1.c ****     *  Returns the number of bytes in the TX buffer which are waiting to be 
1248:Generated_Source\PSoC4/UART_1.c ****     *  transmitted.
1249:Generated_Source\PSoC4/UART_1.c ****     *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250:Generated_Source\PSoC4/UART_1.c ****     *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251:Generated_Source\PSoC4/UART_1.c ****     *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252:Generated_Source\PSoC4/UART_1.c ****     *    software buffer which are waiting to be transmitted. Bytes available in the
1253:Generated_Source\PSoC4/UART_1.c ****     *    TX FIFO do not count.
1254:Generated_Source\PSoC4/UART_1.c ****     *
1255:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1256:Generated_Source\PSoC4/UART_1.c ****     *  None.
1257:Generated_Source\PSoC4/UART_1.c ****     *
1258:Generated_Source\PSoC4/UART_1.c ****     * Return:
1259:Generated_Source\PSoC4/UART_1.c ****     *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260:Generated_Source\PSoC4/UART_1.c ****     *  Buffer Size parameter.
1261:Generated_Source\PSoC4/UART_1.c ****     *
1262:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1263:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - used to calculate left space.
1264:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - used to calculate left space.
1265:Generated_Source\PSoC4/UART_1.c ****     *
1266:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1267:Generated_Source\PSoC4/UART_1.c ****     *  No.
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 43


1268:Generated_Source\PSoC4/UART_1.c ****     *
1269:Generated_Source\PSoC4/UART_1.c ****     * Theory:
1270:Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the TX Buffer is.
1271:Generated_Source\PSoC4/UART_1.c ****     *
1272:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1273:Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetTxBufferSize(void)
1274:Generated_Source\PSoC4/UART_1.c ****                                                             
1275:Generated_Source\PSoC4/UART_1.c ****     {
 1125              		.loc 1 1275 0
 1126              		.cfi_startproc
 1127 0000 80B5     		push	{r7, lr}
 1128              		.cfi_def_cfa_offset 8
 1129              		.cfi_offset 7, -8
 1130              		.cfi_offset 14, -4
 1131 0002 82B0     		sub	sp, sp, #8
 1132              		.cfi_def_cfa_offset 16
 1133 0004 00AF     		add	r7, sp, #0
 1134              		.cfi_def_cfa_register 7
1276:Generated_Source\PSoC4/UART_1.c ****         uint8 size;
1277:Generated_Source\PSoC4/UART_1.c **** 
1278:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1279:Generated_Source\PSoC4/UART_1.c **** 
1280:Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt. */
1281:Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableTxInt();
1282:Generated_Source\PSoC4/UART_1.c **** 
1283:Generated_Source\PSoC4/UART_1.c ****         if(UART_1_txBufferRead == UART_1_txBufferWrite)
1284:Generated_Source\PSoC4/UART_1.c ****         {
1285:Generated_Source\PSoC4/UART_1.c ****             size = 0u;
1286:Generated_Source\PSoC4/UART_1.c ****         }
1287:Generated_Source\PSoC4/UART_1.c ****         else if(UART_1_txBufferRead < UART_1_txBufferWrite)
1288:Generated_Source\PSoC4/UART_1.c ****         {
1289:Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_txBufferWrite - UART_1_txBufferRead);
1290:Generated_Source\PSoC4/UART_1.c ****         }
1291:Generated_Source\PSoC4/UART_1.c ****         else
1292:Generated_Source\PSoC4/UART_1.c ****         {
1293:Generated_Source\PSoC4/UART_1.c ****             size = (UART_1_TX_BUFFER_SIZE - UART_1_txBufferRead) +
1294:Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite;
1295:Generated_Source\PSoC4/UART_1.c ****         }
1296:Generated_Source\PSoC4/UART_1.c **** 
1297:Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableTxInt();
1298:Generated_Source\PSoC4/UART_1.c **** 
1299:Generated_Source\PSoC4/UART_1.c ****     #else
1300:Generated_Source\PSoC4/UART_1.c **** 
1301:Generated_Source\PSoC4/UART_1.c ****         size = UART_1_TXSTATUS_REG;
 1135              		.loc 1 1301 0
 1136 0006 0F4A     		ldr	r2, .L87
 1137 0008 FB1D     		add	r3, r7, #7
 1138 000a 1278     		ldrb	r2, [r2]
 1139 000c 1A70     		strb	r2, [r3]
1302:Generated_Source\PSoC4/UART_1.c **** 
1303:Generated_Source\PSoC4/UART_1.c ****         /* Is the fifo is full. */
1304:Generated_Source\PSoC4/UART_1.c ****         if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
 1140              		.loc 1 1304 0
 1141 000e FB1D     		add	r3, r7, #7
 1142 0010 1B78     		ldrb	r3, [r3]
 1143 0012 0422     		mov	r2, #4
 1144 0014 1340     		and	r3, r2
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 44


 1145 0016 03D0     		beq	.L83
1305:Generated_Source\PSoC4/UART_1.c ****         {
1306:Generated_Source\PSoC4/UART_1.c ****             size = UART_1_FIFO_LENGTH;
 1146              		.loc 1 1306 0
 1147 0018 FB1D     		add	r3, r7, #7
 1148 001a 0422     		mov	r2, #4
 1149 001c 1A70     		strb	r2, [r3]
 1150 001e 0BE0     		b	.L84
 1151              	.L83:
1307:Generated_Source\PSoC4/UART_1.c ****         }
1308:Generated_Source\PSoC4/UART_1.c ****         else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
 1152              		.loc 1 1308 0
 1153 0020 FB1D     		add	r3, r7, #7
 1154 0022 1B78     		ldrb	r3, [r3]
 1155 0024 0222     		mov	r2, #2
 1156 0026 1340     		and	r3, r2
 1157 0028 03D0     		beq	.L85
1309:Generated_Source\PSoC4/UART_1.c ****         {
1310:Generated_Source\PSoC4/UART_1.c ****             size = 0u;
 1158              		.loc 1 1310 0
 1159 002a FB1D     		add	r3, r7, #7
 1160 002c 0022     		mov	r2, #0
 1161 002e 1A70     		strb	r2, [r3]
 1162 0030 02E0     		b	.L84
 1163              	.L85:
1311:Generated_Source\PSoC4/UART_1.c ****         }
1312:Generated_Source\PSoC4/UART_1.c ****         else
1313:Generated_Source\PSoC4/UART_1.c ****         {
1314:Generated_Source\PSoC4/UART_1.c ****             /* We only know there is data in the fifo. */
1315:Generated_Source\PSoC4/UART_1.c ****             size = 1u;
 1164              		.loc 1 1315 0
 1165 0032 FB1D     		add	r3, r7, #7
 1166 0034 0122     		mov	r2, #1
 1167 0036 1A70     		strb	r2, [r3]
 1168              	.L84:
1316:Generated_Source\PSoC4/UART_1.c ****         }
1317:Generated_Source\PSoC4/UART_1.c **** 
1318:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1319:Generated_Source\PSoC4/UART_1.c **** 
1320:Generated_Source\PSoC4/UART_1.c ****     return(size);
 1169              		.loc 1 1320 0
 1170 0038 FB1D     		add	r3, r7, #7
 1171 003a 1B78     		ldrb	r3, [r3]
1321:Generated_Source\PSoC4/UART_1.c ****     }
 1172              		.loc 1 1321 0
 1173 003c 181C     		mov	r0, r3
 1174 003e BD46     		mov	sp, r7
 1175 0040 02B0     		add	sp, sp, #8
 1176              		@ sp needed
 1177 0042 80BD     		pop	{r7, pc}
 1178              	.L88:
 1179              		.align	2
 1180              	.L87:
 1181 0044 62000F40 		.word	1074724962
 1182              		.cfi_endproc
 1183              	.LFE24:
 1184              		.size	UART_1_GetTxBufferSize, .-UART_1_GetTxBufferSize
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 45


 1185              		.section	.text.UART_1_ClearTxBuffer,"ax",%progbits
 1186              		.align	2
 1187              		.global	UART_1_ClearTxBuffer
 1188              		.code	16
 1189              		.thumb_func
 1190              		.type	UART_1_ClearTxBuffer, %function
 1191              	UART_1_ClearTxBuffer:
 1192              	.LFB25:
1322:Generated_Source\PSoC4/UART_1.c **** 
1323:Generated_Source\PSoC4/UART_1.c **** 
1324:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1325:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearTxBuffer
1326:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1327:Generated_Source\PSoC4/UART_1.c ****     *
1328:Generated_Source\PSoC4/UART_1.c ****     * Summary:
1329:Generated_Source\PSoC4/UART_1.c ****     *  Clears all data from the TX buffer and hardware TX FIFO.
1330:Generated_Source\PSoC4/UART_1.c ****     *
1331:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1332:Generated_Source\PSoC4/UART_1.c ****     *  None.
1333:Generated_Source\PSoC4/UART_1.c ****     *
1334:Generated_Source\PSoC4/UART_1.c ****     * Return:
1335:Generated_Source\PSoC4/UART_1.c ****     *  None.
1336:Generated_Source\PSoC4/UART_1.c ****     *
1337:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1338:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cleared to zero.
1339:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cleared to zero.
1340:Generated_Source\PSoC4/UART_1.c ****     *
1341:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1342:Generated_Source\PSoC4/UART_1.c ****     *  No.
1343:Generated_Source\PSoC4/UART_1.c ****     *
1344:Generated_Source\PSoC4/UART_1.c ****     * Theory:
1345:Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1346:Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1347:Generated_Source\PSoC4/UART_1.c ****     *  remained in the RAM.
1348:Generated_Source\PSoC4/UART_1.c ****     *
1349:Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1350:Generated_Source\PSoC4/UART_1.c ****     *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351:Generated_Source\PSoC4/UART_1.c ****     *  transmitting finishes transmitting.
1352:Generated_Source\PSoC4/UART_1.c ****     *
1353:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1354:Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearTxBuffer(void) 
1355:Generated_Source\PSoC4/UART_1.c ****     {
 1193              		.loc 1 1355 0
 1194              		.cfi_startproc
 1195 0000 90B5     		push	{r4, r7, lr}
 1196              		.cfi_def_cfa_offset 12
 1197              		.cfi_offset 4, -12
 1198              		.cfi_offset 7, -8
 1199              		.cfi_offset 14, -4
 1200 0002 83B0     		sub	sp, sp, #12
 1201              		.cfi_def_cfa_offset 24
 1202 0004 00AF     		add	r7, sp, #0
 1203              		.cfi_def_cfa_register 7
1356:Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
1357:Generated_Source\PSoC4/UART_1.c **** 
1358:Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 1204              		.loc 1 1358 0
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 46


 1205 0006 FC1D     		add	r4, r7, #7
 1206 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 1207 000c 031C     		mov	r3, r0
 1208 000e 2370     		strb	r3, [r4]
1359:Generated_Source\PSoC4/UART_1.c ****         /* Clear the HW FIFO */
1360:Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG |= (uint8)  UART_1_TX_FIFO_CLR;
 1209              		.loc 1 1360 0
 1210 0010 0B4A     		ldr	r2, .L90
 1211 0012 0B4B     		ldr	r3, .L90
 1212 0014 1B78     		ldrb	r3, [r3]
 1213 0016 DBB2     		uxtb	r3, r3
 1214 0018 0121     		mov	r1, #1
 1215 001a 0B43     		orr	r3, r1
 1216 001c DBB2     		uxtb	r3, r3
 1217 001e 1370     		strb	r3, [r2]
1361:Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG &= (uint8) ~UART_1_TX_FIFO_CLR;
 1218              		.loc 1 1361 0
 1219 0020 074A     		ldr	r2, .L90
 1220 0022 074B     		ldr	r3, .L90
 1221 0024 1B78     		ldrb	r3, [r3]
 1222 0026 DBB2     		uxtb	r3, r3
 1223 0028 0121     		mov	r1, #1
 1224 002a 8B43     		bic	r3, r1
 1225 002c DBB2     		uxtb	r3, r3
 1226 002e 1370     		strb	r3, [r2]
1362:Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 1227              		.loc 1 1362 0
 1228 0030 FB1D     		add	r3, r7, #7
 1229 0032 1B78     		ldrb	r3, [r3]
 1230 0034 181C     		mov	r0, r3
 1231 0036 FFF7FEFF 		bl	CyExitCriticalSection
1363:Generated_Source\PSoC4/UART_1.c **** 
1364:Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_TX_INTERRUPT_ENABLED)
1365:Generated_Source\PSoC4/UART_1.c **** 
1366:Generated_Source\PSoC4/UART_1.c ****         /* Protect variables that could change on interrupt. */
1367:Generated_Source\PSoC4/UART_1.c ****         UART_1_DisableTxInt();
1368:Generated_Source\PSoC4/UART_1.c **** 
1369:Generated_Source\PSoC4/UART_1.c ****         UART_1_txBufferRead = 0u;
1370:Generated_Source\PSoC4/UART_1.c ****         UART_1_txBufferWrite = 0u;
1371:Generated_Source\PSoC4/UART_1.c **** 
1372:Generated_Source\PSoC4/UART_1.c ****         /* Enable Tx interrupt. */
1373:Generated_Source\PSoC4/UART_1.c ****         UART_1_EnableTxInt();
1374:Generated_Source\PSoC4/UART_1.c **** 
1375:Generated_Source\PSoC4/UART_1.c ****     #endif /* (UART_1_TX_INTERRUPT_ENABLED) */
1376:Generated_Source\PSoC4/UART_1.c ****     }
 1232              		.loc 1 1376 0
 1233 003a BD46     		mov	sp, r7
 1234 003c 03B0     		add	sp, sp, #12
 1235              		@ sp needed
 1236 003e 90BD     		pop	{r4, r7, pc}
 1237              	.L91:
 1238              		.align	2
 1239              	.L90:
 1240 0040 92000F40 		.word	1074725010
 1241              		.cfi_endproc
 1242              	.LFE25:
 1243              		.size	UART_1_ClearTxBuffer, .-UART_1_ClearTxBuffer
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 47


 1244              		.section	.text.UART_1_SendBreak,"ax",%progbits
 1245              		.align	2
 1246              		.global	UART_1_SendBreak
 1247              		.code	16
 1248              		.thumb_func
 1249              		.type	UART_1_SendBreak, %function
 1250              	UART_1_SendBreak:
 1251              	.LFB26:
1377:Generated_Source\PSoC4/UART_1.c **** 
1378:Generated_Source\PSoC4/UART_1.c **** 
1379:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1380:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SendBreak
1381:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1382:Generated_Source\PSoC4/UART_1.c ****     *
1383:Generated_Source\PSoC4/UART_1.c ****     * Summary:
1384:Generated_Source\PSoC4/UART_1.c ****     *  Transmits a break signal on the bus.
1385:Generated_Source\PSoC4/UART_1.c ****     *
1386:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1387:Generated_Source\PSoC4/UART_1.c ****     *  uint8 retMode:  Send Break return mode. See the following table for options.
1388:Generated_Source\PSoC4/UART_1.c ****     *   UART_1_SEND_BREAK - Initialize registers for break, send the Break
1389:Generated_Source\PSoC4/UART_1.c ****     *       signal and return immediately.
1390:Generated_Source\PSoC4/UART_1.c ****     *   UART_1_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391:Generated_Source\PSoC4/UART_1.c ****     *       complete, reinitialize registers to normal transmission mode then return
1392:Generated_Source\PSoC4/UART_1.c ****     *   UART_1_REINIT - Reinitialize registers to normal transmission mode
1393:Generated_Source\PSoC4/UART_1.c ****     *       then return.
1394:Generated_Source\PSoC4/UART_1.c ****     *   UART_1_SEND_WAIT_REINIT - Performs both options: 
1395:Generated_Source\PSoC4/UART_1.c ****     *      UART_1_SEND_BREAK and UART_1_WAIT_FOR_COMPLETE_REINIT.
1396:Generated_Source\PSoC4/UART_1.c ****     *      This option is recommended for most cases.
1397:Generated_Source\PSoC4/UART_1.c ****     *
1398:Generated_Source\PSoC4/UART_1.c ****     * Return:
1399:Generated_Source\PSoC4/UART_1.c ****     *  None.
1400:Generated_Source\PSoC4/UART_1.c ****     *
1401:Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1402:Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1403:Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1404:Generated_Source\PSoC4/UART_1.c ****     *  txPeriod - static variable, used for keeping TX period configuration.
1405:Generated_Source\PSoC4/UART_1.c ****     *
1406:Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1407:Generated_Source\PSoC4/UART_1.c ****     *  No.
1408:Generated_Source\PSoC4/UART_1.c ****     *
1409:Generated_Source\PSoC4/UART_1.c ****     * Theory:
1410:Generated_Source\PSoC4/UART_1.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1411:Generated_Source\PSoC4/UART_1.c ****     *  important to return the registers configuration to normal for continue 8-bit
1412:Generated_Source\PSoC4/UART_1.c ****     *  operation.
1413:Generated_Source\PSoC4/UART_1.c ****     *  There are 3 variants for this API usage:
1414:Generated_Source\PSoC4/UART_1.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1415:Generated_Source\PSoC4/UART_1.c ****     *     configuration returning. Function will block CPU until transmission
1416:Generated_Source\PSoC4/UART_1.c ****     *     complete.
1417:Generated_Source\PSoC4/UART_1.c ****     *  2) User may want to use blocking time if UART configured to the low speed
1418:Generated_Source\PSoC4/UART_1.c ****     *     operation
1419:Generated_Source\PSoC4/UART_1.c ****     *     Example for this case:
1420:Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - initialize Break signal transmission
1421:Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1422:Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(1);     - complete Break operation
1423:Generated_Source\PSoC4/UART_1.c ****     *  3) Same to 2) but user may want to initialize and use the interrupt to
1424:Generated_Source\PSoC4/UART_1.c ****     *     complete break operation.
1425:Generated_Source\PSoC4/UART_1.c ****     *     Example for this case:
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 48


1426:Generated_Source\PSoC4/UART_1.c ****     *     Initialize TX interrupt with "TX - On TX Complete" parameter
1427:Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - initialize Break signal transmission
1428:Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1429:Generated_Source\PSoC4/UART_1.c ****     *     When interrupt appear with UART_1_TX_STS_COMPLETE status:
1430:Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(2);     - complete Break operation
1431:Generated_Source\PSoC4/UART_1.c ****     *
1432:Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1433:Generated_Source\PSoC4/UART_1.c ****     *  The UART_1_SendBreak() function initializes registers to send a
1434:Generated_Source\PSoC4/UART_1.c ****     *  break signal.
1435:Generated_Source\PSoC4/UART_1.c ****     *  Break signal length depends on the break signal bits configuration.
1436:Generated_Source\PSoC4/UART_1.c ****     *  The register configuration should be reinitialized before normal 8-bit
1437:Generated_Source\PSoC4/UART_1.c ****     *  communication can continue.
1438:Generated_Source\PSoC4/UART_1.c ****     *
1439:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1440:Generated_Source\PSoC4/UART_1.c ****     void UART_1_SendBreak(uint8 retMode) 
1441:Generated_Source\PSoC4/UART_1.c ****     {
 1252              		.loc 1 1441 0
 1253              		.cfi_startproc
 1254 0000 80B5     		push	{r7, lr}
 1255              		.cfi_def_cfa_offset 8
 1256              		.cfi_offset 7, -8
 1257              		.cfi_offset 14, -4
 1258 0002 84B0     		sub	sp, sp, #16
 1259              		.cfi_def_cfa_offset 24
 1260 0004 00AF     		add	r7, sp, #0
 1261              		.cfi_def_cfa_register 7
 1262 0006 021C     		mov	r2, r0
 1263 0008 FB1D     		add	r3, r7, #7
 1264 000a 1A70     		strb	r2, [r3]
1442:Generated_Source\PSoC4/UART_1.c **** 
1443:Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1444:Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 1265              		.loc 1 1444 0
 1266 000c 254B     		ldr	r3, .L100
 1267 000e 1B78     		ldrb	r3, [r3]
 1268 0010 002B     		cmp	r3, #0
 1269 0012 43D0     		beq	.L92
 1270              	.LBB2:
1445:Generated_Source\PSoC4/UART_1.c ****         {
1446:Generated_Source\PSoC4/UART_1.c ****             /* Set the Counter to 13-bits and transmit a 00 byte */
1447:Generated_Source\PSoC4/UART_1.c ****             /* When that is done then reset the counter value back */
1448:Generated_Source\PSoC4/UART_1.c ****             uint8 tmpStat;
1449:Generated_Source\PSoC4/UART_1.c **** 
1450:Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
1451:Generated_Source\PSoC4/UART_1.c **** 
1452:Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_SEND_BREAK) ||
1453:Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT ) )
1454:Generated_Source\PSoC4/UART_1.c ****             {
1455:Generated_Source\PSoC4/UART_1.c ****                 /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
1456:Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1457:Generated_Source\PSoC4/UART_1.c ****                                                       UART_1_CTRL_HD_SEND_BREAK);
1458:Generated_Source\PSoC4/UART_1.c ****                 /* Send zeros */
1459:Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = 0u;
1460:Generated_Source\PSoC4/UART_1.c **** 
1461:Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit starts */
1462:Generated_Source\PSoC4/UART_1.c ****                 {
1463:Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 49


1464:Generated_Source\PSoC4/UART_1.c ****                 }
1465:Generated_Source\PSoC4/UART_1.c ****                 while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1466:Generated_Source\PSoC4/UART_1.c ****             }
1467:Generated_Source\PSoC4/UART_1.c **** 
1468:Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1469:Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1470:Generated_Source\PSoC4/UART_1.c ****             {
1471:Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit complete */
1472:Generated_Source\PSoC4/UART_1.c ****                 {
1473:Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
1474:Generated_Source\PSoC4/UART_1.c ****                 }
1475:Generated_Source\PSoC4/UART_1.c ****                 while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1476:Generated_Source\PSoC4/UART_1.c ****             }
1477:Generated_Source\PSoC4/UART_1.c **** 
1478:Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1479:Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_REINIT) ||
1480:Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1481:Generated_Source\PSoC4/UART_1.c ****             {
1482:Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1483:Generated_Source\PSoC4/UART_1.c ****                                               (uint8)~UART_1_CTRL_HD_SEND_BREAK);
1484:Generated_Source\PSoC4/UART_1.c ****             }
1485:Generated_Source\PSoC4/UART_1.c **** 
1486:Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_HD_ENABLED Full Duplex mode */
1487:Generated_Source\PSoC4/UART_1.c **** 
1488:Generated_Source\PSoC4/UART_1.c ****             static uint8 txPeriod;
1489:Generated_Source\PSoC4/UART_1.c **** 
1490:Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_SEND_BREAK) ||
 1271              		.loc 1 1490 0
 1272 0014 FB1D     		add	r3, r7, #7
 1273 0016 1B78     		ldrb	r3, [r3]
 1274 0018 002B     		cmp	r3, #0
 1275 001a 03D0     		beq	.L94
 1276              		.loc 1 1490 0 is_stmt 0 discriminator 1
 1277 001c FB1D     		add	r3, r7, #7
 1278 001e 1B78     		ldrb	r3, [r3]
 1279 0020 032B     		cmp	r3, #3
 1280 0022 15D1     		bne	.L95
 1281              	.L94:
1491:Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1492:Generated_Source\PSoC4/UART_1.c ****             {
1493:Generated_Source\PSoC4/UART_1.c ****                 /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode
1494:Generated_Source\PSoC4/UART_1.c ****                 #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1495:Generated_Source\PSoC4/UART_1.c ****                                     (UART_1_PARITY_TYPE_SW != 0u) )
1496:Generated_Source\PSoC4/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1497:Generated_Source\PSoC4/UART_1.c ****                                                           UART_1_CTRL_HD_SEND_BREAK);
1498:Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1499:Generated_Source\PSoC4/UART_1.c **** 
1500:Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_TXCLKGEN_DP)
1501:Generated_Source\PSoC4/UART_1.c ****                     txPeriod = UART_1_TXBITCLKTX_COMPLETE_REG;
 1282              		.loc 1 1501 0 is_stmt 1
 1283 0024 204B     		ldr	r3, .L100+4
 1284 0026 1B78     		ldrb	r3, [r3]
 1285 0028 DAB2     		uxtb	r2, r3
 1286 002a 204B     		ldr	r3, .L100+8
 1287 002c 1A70     		strb	r2, [r3]
1502:Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
 1288              		.loc 1 1502 0
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 50


 1289 002e 1E4B     		ldr	r3, .L100+4
 1290 0030 6722     		mov	r2, #103
 1291 0032 1A70     		strb	r2, [r3]
1503:Generated_Source\PSoC4/UART_1.c ****                 #else
1504:Generated_Source\PSoC4/UART_1.c ****                     txPeriod = UART_1_TXBITCTR_PERIOD_REG;
1505:Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
1506:Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_TXCLKGEN_DP */
1507:Generated_Source\PSoC4/UART_1.c **** 
1508:Generated_Source\PSoC4/UART_1.c ****                 /* Send zeros */
1509:Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = 0u;
 1292              		.loc 1 1509 0
 1293 0034 1E4B     		ldr	r3, .L100+12
 1294 0036 0022     		mov	r2, #0
 1295 0038 1A70     		strb	r2, [r3]
 1296              	.L96:
1510:Generated_Source\PSoC4/UART_1.c **** 
1511:Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit starts */
1512:Generated_Source\PSoC4/UART_1.c ****                 {
1513:Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
 1297              		.loc 1 1513 0 discriminator 1
 1298 003a 1E4A     		ldr	r2, .L100+16
 1299 003c 0F23     		mov	r3, #15
 1300 003e FB18     		add	r3, r7, r3
 1301 0040 1278     		ldrb	r2, [r2]
 1302 0042 1A70     		strb	r2, [r3]
1514:Generated_Source\PSoC4/UART_1.c ****                 }
1515:Generated_Source\PSoC4/UART_1.c ****                 while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
 1303              		.loc 1 1515 0 discriminator 1
 1304 0044 0F23     		mov	r3, #15
 1305 0046 FB18     		add	r3, r7, r3
 1306 0048 1B78     		ldrb	r3, [r3]
 1307 004a 0222     		mov	r2, #2
 1308 004c 1340     		and	r3, r2
 1309 004e F4D1     		bne	.L96
 1310              	.L95:
1516:Generated_Source\PSoC4/UART_1.c ****             }
1517:Generated_Source\PSoC4/UART_1.c **** 
1518:Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 1311              		.loc 1 1518 0
 1312 0050 FB1D     		add	r3, r7, #7
 1313 0052 1B78     		ldrb	r3, [r3]
 1314 0054 012B     		cmp	r3, #1
 1315 0056 03D0     		beq	.L97
 1316              		.loc 1 1518 0 is_stmt 0 discriminator 1
 1317 0058 FB1D     		add	r3, r7, #7
 1318 005a 1B78     		ldrb	r3, [r3]
 1319 005c 032B     		cmp	r3, #3
 1320 005e 0DD1     		bne	.L98
 1321              	.L97:
1519:Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1520:Generated_Source\PSoC4/UART_1.c ****             {
1521:Generated_Source\PSoC4/UART_1.c ****                 do /* Wait until transmit complete */
1522:Generated_Source\PSoC4/UART_1.c ****                 {
1523:Generated_Source\PSoC4/UART_1.c ****                     tmpStat = UART_1_TXSTATUS_REG;
 1322              		.loc 1 1523 0 is_stmt 1 discriminator 1
 1323 0060 144A     		ldr	r2, .L100+16
 1324 0062 0F23     		mov	r3, #15
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 51


 1325 0064 FB18     		add	r3, r7, r3
 1326 0066 1278     		ldrb	r2, [r2]
 1327 0068 1A70     		strb	r2, [r3]
1524:Generated_Source\PSoC4/UART_1.c ****                 }
1525:Generated_Source\PSoC4/UART_1.c ****                 while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
 1328              		.loc 1 1525 0 discriminator 1
 1329 006a 0F23     		mov	r3, #15
 1330 006c FB18     		add	r3, r7, r3
 1331 006e 1B78     		ldrb	r3, [r3]
 1332 0070 DB43     		mvn	r3, r3
 1333 0072 DBB2     		uxtb	r3, r3
 1334 0074 1A1C     		mov	r2, r3
 1335 0076 0123     		mov	r3, #1
 1336 0078 1340     		and	r3, r2
 1337 007a F1D1     		bne	.L97
 1338              	.L98:
1526:Generated_Source\PSoC4/UART_1.c ****             }
1527:Generated_Source\PSoC4/UART_1.c **** 
1528:Generated_Source\PSoC4/UART_1.c ****             if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 1339              		.loc 1 1528 0
 1340 007c FB1D     		add	r3, r7, #7
 1341 007e 1B78     		ldrb	r3, [r3]
 1342 0080 012B     		cmp	r3, #1
 1343 0082 07D0     		beq	.L99
 1344              		.loc 1 1528 0 is_stmt 0 discriminator 1
 1345 0084 FB1D     		add	r3, r7, #7
 1346 0086 1B78     		ldrb	r3, [r3]
 1347 0088 022B     		cmp	r3, #2
 1348 008a 03D0     		beq	.L99
1529:Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_REINIT) ||
 1349              		.loc 1 1529 0 is_stmt 1
 1350 008c FB1D     		add	r3, r7, #7
 1351 008e 1B78     		ldrb	r3, [r3]
 1352 0090 032B     		cmp	r3, #3
 1353 0092 03D1     		bne	.L92
 1354              	.L99:
1530:Generated_Source\PSoC4/UART_1.c ****                 (retMode == UART_1_SEND_WAIT_REINIT) )
1531:Generated_Source\PSoC4/UART_1.c ****             {
1532:Generated_Source\PSoC4/UART_1.c **** 
1533:Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TXCLKGEN_DP)
1534:Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXBITCLKTX_COMPLETE_REG = txPeriod;
 1355              		.loc 1 1534 0
 1356 0094 044A     		ldr	r2, .L100+4
 1357 0096 054B     		ldr	r3, .L100+8
 1358 0098 1B78     		ldrb	r3, [r3]
 1359 009a 1370     		strb	r3, [r2]
 1360              	.L92:
 1361              	.LBE2:
1535:Generated_Source\PSoC4/UART_1.c ****             #else
1536:Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXBITCTR_PERIOD_REG = txPeriod;
1537:Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TXCLKGEN_DP */
1538:Generated_Source\PSoC4/UART_1.c **** 
1539:Generated_Source\PSoC4/UART_1.c ****             #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1540:Generated_Source\PSoC4/UART_1.c ****                  (UART_1_PARITY_TYPE_SW != 0u) )
1541:Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1542:Generated_Source\PSoC4/UART_1.c ****                                                       (uint8) ~UART_1_CTRL_HD_SEND_BREAK);
1543:Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_PARITY_TYPE != NONE */
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 52


1544:Generated_Source\PSoC4/UART_1.c ****             }
1545:Generated_Source\PSoC4/UART_1.c ****         #endif    /* End UART_1_HD_ENABLED */
1546:Generated_Source\PSoC4/UART_1.c ****         }
1547:Generated_Source\PSoC4/UART_1.c ****     }
 1362              		.loc 1 1547 0
 1363 009c BD46     		mov	sp, r7
 1364 009e 04B0     		add	sp, sp, #16
 1365              		@ sp needed
 1366 00a0 80BD     		pop	{r7, pc}
 1367              	.L101:
 1368 00a2 C046     		.align	2
 1369              	.L100:
 1370 00a4 00000000 		.word	UART_1_initVar
 1371 00a8 33000F40 		.word	1074724915
 1372 00ac 01000000 		.word	txPeriod.4898
 1373 00b0 42000F40 		.word	1074724930
 1374 00b4 62000F40 		.word	1074724962
 1375              		.cfi_endproc
 1376              	.LFE26:
 1377              		.size	UART_1_SendBreak, .-UART_1_SendBreak
 1378              		.section	.text.UART_1_SetTxAddressMode,"ax",%progbits
 1379              		.align	2
 1380              		.global	UART_1_SetTxAddressMode
 1381              		.code	16
 1382              		.thumb_func
 1383              		.type	UART_1_SetTxAddressMode, %function
 1384              	UART_1_SetTxAddressMode:
 1385              	.LFB27:
1548:Generated_Source\PSoC4/UART_1.c **** 
1549:Generated_Source\PSoC4/UART_1.c **** 
1550:Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1551:Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxAddressMode
1552:Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1553:Generated_Source\PSoC4/UART_1.c ****     *
1554:Generated_Source\PSoC4/UART_1.c ****     * Summary:
1555:Generated_Source\PSoC4/UART_1.c ****     *  Configures the transmitter to signal the next bytes is address or data.
1556:Generated_Source\PSoC4/UART_1.c ****     *
1557:Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1558:Generated_Source\PSoC4/UART_1.c ****     *  addressMode: 
1559:Generated_Source\PSoC4/UART_1.c ****     *       UART_1_SET_SPACE - Configure the transmitter to send the next
1560:Generated_Source\PSoC4/UART_1.c ****     *                                    byte as a data.
1561:Generated_Source\PSoC4/UART_1.c ****     *       UART_1_SET_MARK  - Configure the transmitter to send the next
1562:Generated_Source\PSoC4/UART_1.c ****     *                                    byte as an address.
1563:Generated_Source\PSoC4/UART_1.c ****     *
1564:Generated_Source\PSoC4/UART_1.c ****     * Return:
1565:Generated_Source\PSoC4/UART_1.c ****     *  None.
1566:Generated_Source\PSoC4/UART_1.c ****     *
1567:Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1568:Generated_Source\PSoC4/UART_1.c ****     *  This function sets and clears UART_1_CTRL_MARK bit in the Control
1569:Generated_Source\PSoC4/UART_1.c ****     *  register.
1570:Generated_Source\PSoC4/UART_1.c ****     *
1571:Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1572:Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxAddressMode(uint8 addressMode) 
1573:Generated_Source\PSoC4/UART_1.c ****     {
 1386              		.loc 1 1573 0
 1387              		.cfi_startproc
 1388 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 53


 1389              		.cfi_def_cfa_offset 8
 1390              		.cfi_offset 7, -8
 1391              		.cfi_offset 14, -4
 1392 0002 82B0     		sub	sp, sp, #8
 1393              		.cfi_def_cfa_offset 16
 1394 0004 00AF     		add	r7, sp, #0
 1395              		.cfi_def_cfa_register 7
 1396 0006 021C     		mov	r2, r0
 1397 0008 FB1D     		add	r3, r7, #7
 1398 000a 1A70     		strb	r2, [r3]
1574:Generated_Source\PSoC4/UART_1.c ****         /* Mark/Space sending enable */
1575:Generated_Source\PSoC4/UART_1.c ****         if(addressMode != 0u)
1576:Generated_Source\PSoC4/UART_1.c ****         {
1577:Generated_Source\PSoC4/UART_1.c ****         #if( UART_1_CONTROL_REG_REMOVED == 0u )
1578:Generated_Source\PSoC4/UART_1.c ****             UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1579:Generated_Source\PSoC4/UART_1.c ****                                                   UART_1_CTRL_MARK);
1580:Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1581:Generated_Source\PSoC4/UART_1.c ****         }
1582:Generated_Source\PSoC4/UART_1.c ****         else
1583:Generated_Source\PSoC4/UART_1.c ****         {
1584:Generated_Source\PSoC4/UART_1.c ****         #if( UART_1_CONTROL_REG_REMOVED == 0u )
1585:Generated_Source\PSoC4/UART_1.c ****             UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1586:Generated_Source\PSoC4/UART_1.c ****                                                   (uint8) ~UART_1_CTRL_MARK);
1587:Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1588:Generated_Source\PSoC4/UART_1.c ****         }
1589:Generated_Source\PSoC4/UART_1.c ****     }
 1399              		.loc 1 1589 0
 1400 000c BD46     		mov	sp, r7
 1401 000e 02B0     		add	sp, sp, #8
 1402              		@ sp needed
 1403 0010 80BD     		pop	{r7, pc}
 1404              		.cfi_endproc
 1405              	.LFE27:
 1406              		.size	UART_1_SetTxAddressMode, .-UART_1_SetTxAddressMode
 1407 0012 C046     		.bss
 1408              	txPeriod.4898:
 1409 0001 00       		.space	1
 1410              		.text
 1411              	.Letext0:
 1412              		.file 2 "Generated_Source\\PSoC4\\cytypes.h"
 1413              		.section	.debug_info,"",%progbits
 1414              	.Ldebug_info0:
 1415 0000 FF040000 		.4byte	0x4ff
 1416 0004 0400     		.2byte	0x4
 1417 0006 00000000 		.4byte	.Ldebug_abbrev0
 1418 000a 04       		.byte	0x4
 1419 000b 01       		.uleb128 0x1
 1420 000c B6030000 		.4byte	.LASF60
 1421 0010 01       		.byte	0x1
 1422 0011 25010000 		.4byte	.LASF61
 1423 0015 13030000 		.4byte	.LASF62
 1424 0019 00000000 		.4byte	.Ldebug_ranges0+0
 1425 001d 00000000 		.4byte	0
 1426 0021 00000000 		.4byte	.Ldebug_line0
 1427 0025 02       		.uleb128 0x2
 1428 0026 01       		.byte	0x1
 1429 0027 06       		.byte	0x6
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 54


 1430 0028 9C000000 		.4byte	.LASF0
 1431 002c 02       		.uleb128 0x2
 1432 002d 01       		.byte	0x1
 1433 002e 08       		.byte	0x8
 1434 002f C6020000 		.4byte	.LASF1
 1435 0033 02       		.uleb128 0x2
 1436 0034 02       		.byte	0x2
 1437 0035 05       		.byte	0x5
 1438 0036 D4020000 		.4byte	.LASF2
 1439 003a 02       		.uleb128 0x2
 1440 003b 02       		.byte	0x2
 1441 003c 07       		.byte	0x7
 1442 003d 85010000 		.4byte	.LASF3
 1443 0041 02       		.uleb128 0x2
 1444 0042 04       		.byte	0x4
 1445 0043 05       		.byte	0x5
 1446 0044 C0000000 		.4byte	.LASF4
 1447 0048 02       		.uleb128 0x2
 1448 0049 04       		.byte	0x4
 1449 004a 07       		.byte	0x7
 1450 004b 6E010000 		.4byte	.LASF5
 1451 004f 02       		.uleb128 0x2
 1452 0050 08       		.byte	0x8
 1453 0051 05       		.byte	0x5
 1454 0052 8E000000 		.4byte	.LASF6
 1455 0056 02       		.uleb128 0x2
 1456 0057 08       		.byte	0x8
 1457 0058 07       		.byte	0x7
 1458 0059 60000000 		.4byte	.LASF7
 1459 005d 03       		.uleb128 0x3
 1460 005e 04       		.byte	0x4
 1461 005f 05       		.byte	0x5
 1462 0060 696E7400 		.ascii	"int\000"
 1463 0064 02       		.uleb128 0x2
 1464 0065 04       		.byte	0x4
 1465 0066 07       		.byte	0x7
 1466 0067 4D010000 		.4byte	.LASF8
 1467 006b 04       		.uleb128 0x4
 1468 006c D6000000 		.4byte	.LASF9
 1469 0070 02       		.byte	0x2
 1470 0071 9801     		.2byte	0x198
 1471 0073 2C000000 		.4byte	0x2c
 1472 0077 04       		.uleb128 0x4
 1473 0078 00000000 		.4byte	.LASF10
 1474 007c 02       		.byte	0x2
 1475 007d 9901     		.2byte	0x199
 1476 007f 3A000000 		.4byte	0x3a
 1477 0083 02       		.uleb128 0x2
 1478 0084 04       		.byte	0x4
 1479 0085 04       		.byte	0x4
 1480 0086 7D020000 		.4byte	.LASF11
 1481 008a 02       		.uleb128 0x2
 1482 008b 08       		.byte	0x8
 1483 008c 04       		.byte	0x4
 1484 008d DC000000 		.4byte	.LASF12
 1485 0091 04       		.uleb128 0x4
 1486 0092 8C030000 		.4byte	.LASF13
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 55


 1487 0096 02       		.byte	0x2
 1488 0097 A901     		.2byte	0x1a9
 1489 0099 9D000000 		.4byte	0x9d
 1490 009d 02       		.uleb128 0x2
 1491 009e 01       		.byte	0x1
 1492 009f 08       		.byte	0x8
 1493 00a0 87030000 		.4byte	.LASF14
 1494 00a4 04       		.uleb128 0x4
 1495 00a5 C1020000 		.4byte	.LASF15
 1496 00a9 02       		.byte	0x2
 1497 00aa 4202     		.2byte	0x242
 1498 00ac B0000000 		.4byte	0xb0
 1499 00b0 05       		.uleb128 0x5
 1500 00b1 6B000000 		.4byte	0x6b
 1501 00b5 02       		.uleb128 0x2
 1502 00b6 04       		.byte	0x4
 1503 00b7 07       		.byte	0x7
 1504 00b8 1F020000 		.4byte	.LASF16
 1505 00bc 06       		.uleb128 0x6
 1506 00bd C9000000 		.4byte	.LASF17
 1507 00c1 01       		.byte	0x1
 1508 00c2 4C       		.byte	0x4c
 1509 00c3 00000000 		.4byte	.LFB1
 1510 00c7 24000000 		.4byte	.LFE1-.LFB1
 1511 00cb 01       		.uleb128 0x1
 1512 00cc 9C       		.byte	0x9c
 1513 00cd 07       		.uleb128 0x7
 1514 00ce 92030000 		.4byte	.LASF18
 1515 00d2 01       		.byte	0x1
 1516 00d3 6A       		.byte	0x6a
 1517 00d4 00000000 		.4byte	.LFB2
 1518 00d8 3C000000 		.4byte	.LFE2-.LFB2
 1519 00dc 01       		.uleb128 0x1
 1520 00dd 9C       		.byte	0x9c
 1521 00de 08       		.uleb128 0x8
 1522 00df 98010000 		.4byte	.LASF19
 1523 00e3 01       		.byte	0x1
 1524 00e4 B7       		.byte	0xb7
 1525 00e5 00000000 		.4byte	.LFB3
 1526 00e9 64000000 		.4byte	.LFE3-.LFB3
 1527 00ed 01       		.uleb128 0x1
 1528 00ee 9C       		.byte	0x9c
 1529 00ef 02010000 		.4byte	0x102
 1530 00f3 09       		.uleb128 0x9
 1531 00f4 9E030000 		.4byte	.LASF21
 1532 00f8 01       		.byte	0x1
 1533 00f9 B9       		.byte	0xb9
 1534 00fa 6B000000 		.4byte	0x6b
 1535 00fe 02       		.uleb128 0x2
 1536 00ff 91       		.byte	0x91
 1537 0100 6F       		.sleb128 -17
 1538 0101 00       		.byte	0
 1539 0102 08       		.uleb128 0x8
 1540 0103 E9010000 		.4byte	.LASF20
 1541 0107 01       		.byte	0x1
 1542 0108 F0       		.byte	0xf0
 1543 0109 00000000 		.4byte	.LFB4
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 56


 1544 010d 60000000 		.4byte	.LFE4-.LFB4
 1545 0111 01       		.uleb128 0x1
 1546 0112 9C       		.byte	0x9c
 1547 0113 26010000 		.4byte	0x126
 1548 0117 09       		.uleb128 0x9
 1549 0118 9E030000 		.4byte	.LASF21
 1550 011c 01       		.byte	0x1
 1551 011d F2       		.byte	0xf2
 1552 011e 6B000000 		.4byte	0x6b
 1553 0122 02       		.uleb128 0x2
 1554 0123 91       		.byte	0x91
 1555 0124 6F       		.sleb128 -17
 1556 0125 00       		.byte	0
 1557 0126 0A       		.uleb128 0xa
 1558 0127 CE010000 		.4byte	.LASF32
 1559 012b 01       		.byte	0x1
 1560 012c 2701     		.2byte	0x127
 1561 012e 6B000000 		.4byte	0x6b
 1562 0132 00000000 		.4byte	.LFB5
 1563 0136 0C000000 		.4byte	.LFE5-.LFB5
 1564 013a 01       		.uleb128 0x1
 1565 013b 9C       		.byte	0x9c
 1566 013c 0B       		.uleb128 0xb
 1567 013d DE020000 		.4byte	.LASF22
 1568 0141 01       		.byte	0x1
 1569 0142 3F01     		.2byte	0x13f
 1570 0144 00000000 		.4byte	.LFB6
 1571 0148 12000000 		.4byte	.LFE6-.LFB6
 1572 014c 01       		.uleb128 0x1
 1573 014d 9C       		.byte	0x9c
 1574 014e 62010000 		.4byte	0x162
 1575 0152 0C       		.uleb128 0xc
 1576 0153 03010000 		.4byte	.LASF24
 1577 0157 01       		.byte	0x1
 1578 0158 3F01     		.2byte	0x13f
 1579 015a 6B000000 		.4byte	0x6b
 1580 015e 02       		.uleb128 0x2
 1581 015f 91       		.byte	0x91
 1582 0160 77       		.sleb128 -9
 1583 0161 00       		.byte	0
 1584 0162 0B       		.uleb128 0xb
 1585 0163 0B010000 		.4byte	.LASF23
 1586 0167 01       		.byte	0x1
 1587 0168 6701     		.2byte	0x167
 1588 016a 00000000 		.4byte	.LFB7
 1589 016e 20000000 		.4byte	.LFE7-.LFB7
 1590 0172 01       		.uleb128 0x1
 1591 0173 9C       		.byte	0x9c
 1592 0174 88010000 		.4byte	0x188
 1593 0178 0C       		.uleb128 0xc
 1594 0179 C7010000 		.4byte	.LASF25
 1595 017d 01       		.byte	0x1
 1596 017e 6701     		.2byte	0x167
 1597 0180 6B000000 		.4byte	0x6b
 1598 0184 02       		.uleb128 0x2
 1599 0185 91       		.byte	0x91
 1600 0186 77       		.sleb128 -9
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 57


 1601 0187 00       		.byte	0
 1602 0188 0D       		.uleb128 0xd
 1603 0189 4E000000 		.4byte	.LASF27
 1604 018d 01       		.byte	0x1
 1605 018e 8801     		.2byte	0x188
 1606 0190 6B000000 		.4byte	0x6b
 1607 0194 00000000 		.4byte	.LFB8
 1608 0198 20000000 		.4byte	.LFE8-.LFB8
 1609 019c 01       		.uleb128 0x1
 1610 019d 9C       		.byte	0x9c
 1611 019e B2010000 		.4byte	0x1b2
 1612 01a2 0E       		.uleb128 0xe
 1613 01a3 80030000 		.4byte	.LASF26
 1614 01a7 01       		.byte	0x1
 1615 01a8 8A01     		.2byte	0x18a
 1616 01aa 6B000000 		.4byte	0x6b
 1617 01ae 02       		.uleb128 0x2
 1618 01af 91       		.byte	0x91
 1619 01b0 77       		.sleb128 -9
 1620 01b1 00       		.byte	0
 1621 01b2 0D       		.uleb128 0xd
 1622 01b3 EF000000 		.4byte	.LASF28
 1623 01b7 01       		.byte	0x1
 1624 01b8 E501     		.2byte	0x1e5
 1625 01ba 6B000000 		.4byte	0x6b
 1626 01be 00000000 		.4byte	.LFB9
 1627 01c2 24000000 		.4byte	.LFE9-.LFB9
 1628 01c6 01       		.uleb128 0x1
 1629 01c7 9C       		.byte	0x9c
 1630 01c8 DC010000 		.4byte	0x1dc
 1631 01cc 0E       		.uleb128 0xe
 1632 01cd AF030000 		.4byte	.LASF29
 1633 01d1 01       		.byte	0x1
 1634 01d2 E701     		.2byte	0x1e7
 1635 01d4 6B000000 		.4byte	0x6b
 1636 01d8 02       		.uleb128 0x2
 1637 01d9 91       		.byte	0x91
 1638 01da 77       		.sleb128 -9
 1639 01db 00       		.byte	0
 1640 01dc 0D       		.uleb128 0xd
 1641 01dd 44040000 		.4byte	.LASF30
 1642 01e1 01       		.byte	0x1
 1643 01e2 1402     		.2byte	0x214
 1644 01e4 6B000000 		.4byte	0x6b
 1645 01e8 00000000 		.4byte	.LFB10
 1646 01ec 4C000000 		.4byte	.LFE10-.LFB10
 1647 01f0 01       		.uleb128 0x1
 1648 01f1 9C       		.byte	0x9c
 1649 01f2 15020000 		.4byte	0x215
 1650 01f6 0E       		.uleb128 0xe
 1651 01f7 80030000 		.4byte	.LASF26
 1652 01fb 01       		.byte	0x1
 1653 01fc 1602     		.2byte	0x216
 1654 01fe 6B000000 		.4byte	0x6b
 1655 0202 02       		.uleb128 0x2
 1656 0203 91       		.byte	0x91
 1657 0204 77       		.sleb128 -9
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 58


 1658 0205 0E       		.uleb128 0xe
 1659 0206 5A020000 		.4byte	.LASF31
 1660 020a 01       		.byte	0x1
 1661 020b 1702     		.2byte	0x217
 1662 020d 6B000000 		.4byte	0x6b
 1663 0211 02       		.uleb128 0x2
 1664 0212 91       		.byte	0x91
 1665 0213 76       		.sleb128 -10
 1666 0214 00       		.byte	0
 1667 0215 0F       		.uleb128 0xf
 1668 0216 F5010000 		.4byte	.LASF33
 1669 021a 01       		.byte	0x1
 1670 021b 7A02     		.2byte	0x27a
 1671 021d 77000000 		.4byte	0x77
 1672 0221 00000000 		.4byte	.LFB11
 1673 0225 24000000 		.4byte	.LFE11-.LFB11
 1674 0229 01       		.uleb128 0x1
 1675 022a 9C       		.byte	0x9c
 1676 022b 0D       		.uleb128 0xd
 1677 022c 69030000 		.4byte	.LASF34
 1678 0230 01       		.byte	0x1
 1679 0231 AB02     		.2byte	0x2ab
 1680 0233 6B000000 		.4byte	0x6b
 1681 0237 00000000 		.4byte	.LFB12
 1682 023b 30000000 		.4byte	.LFE12-.LFB12
 1683 023f 01       		.uleb128 0x1
 1684 0240 9C       		.byte	0x9c
 1685 0241 55020000 		.4byte	0x255
 1686 0245 0E       		.uleb128 0xe
 1687 0246 80010000 		.4byte	.LASF35
 1688 024a 01       		.byte	0x1
 1689 024b AE02     		.2byte	0x2ae
 1690 024d 6B000000 		.4byte	0x6b
 1691 0251 02       		.uleb128 0x2
 1692 0252 91       		.byte	0x91
 1693 0253 77       		.sleb128 -9
 1694 0254 00       		.byte	0
 1695 0255 10       		.uleb128 0x10
 1696 0256 94020000 		.4byte	.LASF36
 1697 025a 01       		.byte	0x1
 1698 025b F502     		.2byte	0x2f5
 1699 025d 00000000 		.4byte	.LFB13
 1700 0261 44000000 		.4byte	.LFE13-.LFB13
 1701 0265 01       		.uleb128 0x1
 1702 0266 9C       		.byte	0x9c
 1703 0267 7B020000 		.4byte	0x27b
 1704 026b 0E       		.uleb128 0xe
 1705 026c 9E030000 		.4byte	.LASF21
 1706 0270 01       		.byte	0x1
 1707 0271 F702     		.2byte	0x2f7
 1708 0273 6B000000 		.4byte	0x6b
 1709 0277 02       		.uleb128 0x2
 1710 0278 91       		.byte	0x91
 1711 0279 6F       		.sleb128 -17
 1712 027a 00       		.byte	0
 1713 027b 0B       		.uleb128 0xb
 1714 027c A9020000 		.4byte	.LASF37
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 59


 1715 0280 01       		.byte	0x1
 1716 0281 2D03     		.2byte	0x32d
 1717 0283 00000000 		.4byte	.LFB14
 1718 0287 12000000 		.4byte	.LFE14-.LFB14
 1719 028b 01       		.uleb128 0x1
 1720 028c 9C       		.byte	0x9c
 1721 028d A1020000 		.4byte	0x2a1
 1722 0291 0C       		.uleb128 0xc
 1723 0292 E3000000 		.4byte	.LASF38
 1724 0296 01       		.byte	0x1
 1725 0297 2D03     		.2byte	0x32d
 1726 0299 6B000000 		.4byte	0x6b
 1727 029d 02       		.uleb128 0x2
 1728 029e 91       		.byte	0x91
 1729 029f 77       		.sleb128 -9
 1730 02a0 00       		.byte	0
 1731 02a1 0B       		.uleb128 0xb
 1732 02a2 28020000 		.4byte	.LASF39
 1733 02a6 01       		.byte	0x1
 1734 02a7 5903     		.2byte	0x359
 1735 02a9 00000000 		.4byte	.LFB15
 1736 02ad 20000000 		.4byte	.LFE15-.LFB15
 1737 02b1 01       		.uleb128 0x1
 1738 02b2 9C       		.byte	0x9c
 1739 02b3 C7020000 		.4byte	0x2c7
 1740 02b7 0C       		.uleb128 0xc
 1741 02b8 52020000 		.4byte	.LASF40
 1742 02bc 01       		.byte	0x1
 1743 02bd 5903     		.2byte	0x359
 1744 02bf 6B000000 		.4byte	0x6b
 1745 02c3 02       		.uleb128 0x2
 1746 02c4 91       		.byte	0x91
 1747 02c5 77       		.sleb128 -9
 1748 02c6 00       		.byte	0
 1749 02c7 0B       		.uleb128 0xb
 1750 02c8 3D020000 		.4byte	.LASF41
 1751 02cc 01       		.byte	0x1
 1752 02cd 6D03     		.2byte	0x36d
 1753 02cf 00000000 		.4byte	.LFB16
 1754 02d3 20000000 		.4byte	.LFE16-.LFB16
 1755 02d7 01       		.uleb128 0x1
 1756 02d8 9C       		.byte	0x9c
 1757 02d9 ED020000 		.4byte	0x2ed
 1758 02dd 0C       		.uleb128 0xc
 1759 02de 52020000 		.4byte	.LASF40
 1760 02e2 01       		.byte	0x1
 1761 02e3 6D03     		.2byte	0x36d
 1762 02e5 6B000000 		.4byte	0x6b
 1763 02e9 02       		.uleb128 0x2
 1764 02ea 91       		.byte	0x91
 1765 02eb 77       		.sleb128 -9
 1766 02ec 00       		.byte	0
 1767 02ed 0B       		.uleb128 0xb
 1768 02ee 63020000 		.4byte	.LASF42
 1769 02f2 01       		.byte	0x1
 1770 02f3 8C03     		.2byte	0x38c
 1771 02f5 00000000 		.4byte	.LFB17
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 60


 1772 02f9 20000000 		.4byte	.LFE17-.LFB17
 1773 02fd 01       		.uleb128 0x1
 1774 02fe 9C       		.byte	0x9c
 1775 02ff 13030000 		.4byte	0x313
 1776 0303 0C       		.uleb128 0xc
 1777 0304 C7010000 		.4byte	.LASF25
 1778 0308 01       		.byte	0x1
 1779 0309 8C03     		.2byte	0x38c
 1780 030b 6B000000 		.4byte	0x6b
 1781 030f 02       		.uleb128 0x2
 1782 0310 91       		.byte	0x91
 1783 0311 77       		.sleb128 -9
 1784 0312 00       		.byte	0
 1785 0313 0B       		.uleb128 0xb
 1786 0314 04020000 		.4byte	.LASF43
 1787 0318 01       		.byte	0x1
 1788 0319 AE03     		.2byte	0x3ae
 1789 031b 00000000 		.4byte	.LFB18
 1790 031f 2C000000 		.4byte	.LFE18-.LFB18
 1791 0323 01       		.uleb128 0x1
 1792 0324 9C       		.byte	0x9c
 1793 0325 39030000 		.4byte	0x339
 1794 0329 0C       		.uleb128 0xc
 1795 032a 1C000000 		.4byte	.LASF44
 1796 032e 01       		.byte	0x1
 1797 032f AE03     		.2byte	0x3ae
 1798 0331 6B000000 		.4byte	0x6b
 1799 0335 02       		.uleb128 0x2
 1800 0336 91       		.byte	0x91
 1801 0337 77       		.sleb128 -9
 1802 0338 00       		.byte	0
 1803 0339 0A       		.uleb128 0xa
 1804 033a 5A010000 		.4byte	.LASF45
 1805 033e 01       		.byte	0x1
 1806 033f EB03     		.2byte	0x3eb
 1807 0341 6B000000 		.4byte	0x6b
 1808 0345 00000000 		.4byte	.LFB19
 1809 0349 14000000 		.4byte	.LFE19-.LFB19
 1810 034d 01       		.uleb128 0x1
 1811 034e 9C       		.byte	0x9c
 1812 034f 0B       		.uleb128 0xb
 1813 0350 27000000 		.4byte	.LASF46
 1814 0354 01       		.byte	0x1
 1815 0355 1104     		.2byte	0x411
 1816 0357 00000000 		.4byte	.LFB20
 1817 035b 34000000 		.4byte	.LFE20-.LFB20
 1818 035f 01       		.uleb128 0x1
 1819 0360 9C       		.byte	0x9c
 1820 0361 75030000 		.4byte	0x375
 1821 0365 0C       		.uleb128 0xc
 1822 0366 1C000000 		.4byte	.LASF44
 1823 036a 01       		.byte	0x1
 1824 036b 1104     		.2byte	0x411
 1825 036d 6B000000 		.4byte	0x6b
 1826 0371 02       		.uleb128 0x2
 1827 0372 91       		.byte	0x91
 1828 0373 77       		.sleb128 -9
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 61


 1829 0374 00       		.byte	0
 1830 0375 10       		.uleb128 0x10
 1831 0376 83020000 		.4byte	.LASF47
 1832 037a 01       		.byte	0x1
 1833 037b 7904     		.2byte	0x479
 1834 037d 00000000 		.4byte	.LFB21
 1835 0381 54000000 		.4byte	.LFE21-.LFB21
 1836 0385 01       		.uleb128 0x1
 1837 0386 9C       		.byte	0x9c
 1838 0387 AA030000 		.4byte	0x3aa
 1839 038b 0C       		.uleb128 0xc
 1840 038c 36000000 		.4byte	.LASF48
 1841 0390 01       		.byte	0x1
 1842 0391 7904     		.2byte	0x479
 1843 0393 AA030000 		.4byte	0x3aa
 1844 0397 02       		.uleb128 0x2
 1845 0398 91       		.byte	0x91
 1846 0399 6C       		.sleb128 -20
 1847 039a 0E       		.uleb128 0xe
 1848 039b A6010000 		.4byte	.LASF49
 1849 039f 01       		.byte	0x1
 1850 03a0 7B04     		.2byte	0x47b
 1851 03a2 77000000 		.4byte	0x77
 1852 03a6 02       		.uleb128 0x2
 1853 03a7 91       		.byte	0x91
 1854 03a8 76       		.sleb128 -10
 1855 03a9 00       		.byte	0
 1856 03aa 11       		.uleb128 0x11
 1857 03ab 04       		.byte	0x4
 1858 03ac B0030000 		.4byte	0x3b0
 1859 03b0 12       		.uleb128 0x12
 1860 03b1 91000000 		.4byte	0x91
 1861 03b5 10       		.uleb128 0x10
 1862 03b6 53040000 		.4byte	.LASF50
 1863 03ba 01       		.byte	0x1
 1864 03bb A704     		.2byte	0x4a7
 1865 03bd 00000000 		.4byte	.LFB22
 1866 03c1 58000000 		.4byte	.LFE22-.LFB22
 1867 03c5 01       		.uleb128 0x1
 1868 03c6 9C       		.byte	0x9c
 1869 03c7 F9030000 		.4byte	0x3f9
 1870 03cb 0C       		.uleb128 0xc
 1871 03cc 36000000 		.4byte	.LASF48
 1872 03d0 01       		.byte	0x1
 1873 03d1 A704     		.2byte	0x4a7
 1874 03d3 F9030000 		.4byte	0x3f9
 1875 03d7 02       		.uleb128 0x2
 1876 03d8 91       		.byte	0x91
 1877 03d9 6C       		.sleb128 -20
 1878 03da 0C       		.uleb128 0xc
 1879 03db 09030000 		.4byte	.LASF51
 1880 03df 01       		.byte	0x1
 1881 03e0 A704     		.2byte	0x4a7
 1882 03e2 6B000000 		.4byte	0x6b
 1883 03e6 02       		.uleb128 0x2
 1884 03e7 91       		.byte	0x91
 1885 03e8 6B       		.sleb128 -21
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 62


 1886 03e9 0E       		.uleb128 0xe
 1887 03ea A6010000 		.4byte	.LASF49
 1888 03ee 01       		.byte	0x1
 1889 03ef AA04     		.2byte	0x4aa
 1890 03f1 6B000000 		.4byte	0x6b
 1891 03f5 02       		.uleb128 0x2
 1892 03f6 91       		.byte	0x91
 1893 03f7 77       		.sleb128 -9
 1894 03f8 00       		.byte	0
 1895 03f9 11       		.uleb128 0x11
 1896 03fa 04       		.byte	0x4
 1897 03fb FF030000 		.4byte	0x3ff
 1898 03ff 12       		.uleb128 0x12
 1899 0400 6B000000 		.4byte	0x6b
 1900 0404 10       		.uleb128 0x10
 1901 0405 B1000000 		.4byte	.LASF52
 1902 0409 01       		.byte	0x1
 1903 040a CE04     		.2byte	0x4ce
 1904 040c 00000000 		.4byte	.LFB23
 1905 0410 34000000 		.4byte	.LFE23-.LFB23
 1906 0414 01       		.uleb128 0x1
 1907 0415 9C       		.byte	0x9c
 1908 0416 2A040000 		.4byte	0x42a
 1909 041a 0C       		.uleb128 0xc
 1910 041b 1C000000 		.4byte	.LASF44
 1911 041f 01       		.byte	0x1
 1912 0420 CE04     		.2byte	0x4ce
 1913 0422 6B000000 		.4byte	0x6b
 1914 0426 02       		.uleb128 0x2
 1915 0427 91       		.byte	0x91
 1916 0428 77       		.sleb128 -9
 1917 0429 00       		.byte	0
 1918 042a 0D       		.uleb128 0xd
 1919 042b 77000000 		.4byte	.LASF53
 1920 042f 01       		.byte	0x1
 1921 0430 F904     		.2byte	0x4f9
 1922 0432 6B000000 		.4byte	0x6b
 1923 0436 00000000 		.4byte	.LFB24
 1924 043a 48000000 		.4byte	.LFE24-.LFB24
 1925 043e 01       		.uleb128 0x1
 1926 043f 9C       		.byte	0x9c
 1927 0440 54040000 		.4byte	0x454
 1928 0444 0E       		.uleb128 0xe
 1929 0445 80010000 		.4byte	.LASF35
 1930 0449 01       		.byte	0x1
 1931 044a FC04     		.2byte	0x4fc
 1932 044c 6B000000 		.4byte	0x6b
 1933 0450 02       		.uleb128 0x2
 1934 0451 91       		.byte	0x91
 1935 0452 77       		.sleb128 -9
 1936 0453 00       		.byte	0
 1937 0454 10       		.uleb128 0x10
 1938 0455 07000000 		.4byte	.LASF54
 1939 0459 01       		.byte	0x1
 1940 045a 4A05     		.2byte	0x54a
 1941 045c 00000000 		.4byte	.LFB25
 1942 0460 44000000 		.4byte	.LFE25-.LFB25
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 63


 1943 0464 01       		.uleb128 0x1
 1944 0465 9C       		.byte	0x9c
 1945 0466 7A040000 		.4byte	0x47a
 1946 046a 0E       		.uleb128 0xe
 1947 046b 9E030000 		.4byte	.LASF21
 1948 046f 01       		.byte	0x1
 1949 0470 4C05     		.2byte	0x54c
 1950 0472 6B000000 		.4byte	0x6b
 1951 0476 02       		.uleb128 0x2
 1952 0477 91       		.byte	0x91
 1953 0478 6F       		.sleb128 -17
 1954 0479 00       		.byte	0
 1955 047a 0B       		.uleb128 0xb
 1956 047b 3D000000 		.4byte	.LASF55
 1957 047f 01       		.byte	0x1
 1958 0480 A005     		.2byte	0x5a0
 1959 0482 00000000 		.4byte	.LFB26
 1960 0486 B8000000 		.4byte	.LFE26-.LFB26
 1961 048a 01       		.uleb128 0x1
 1962 048b 9C       		.byte	0x9c
 1963 048c CB040000 		.4byte	0x4cb
 1964 0490 0C       		.uleb128 0xc
 1965 0491 45010000 		.4byte	.LASF56
 1966 0495 01       		.byte	0x1
 1967 0496 A005     		.2byte	0x5a0
 1968 0498 6B000000 		.4byte	0x6b
 1969 049c 02       		.uleb128 0x2
 1970 049d 91       		.byte	0x91
 1971 049e 6F       		.sleb128 -17
 1972 049f 13       		.uleb128 0x13
 1973 04a0 14000000 		.4byte	.LBB2
 1974 04a4 88000000 		.4byte	.LBE2-.LBB2
 1975 04a8 0E       		.uleb128 0xe
 1976 04a9 17020000 		.4byte	.LASF57
 1977 04ad 01       		.byte	0x1
 1978 04ae A805     		.2byte	0x5a8
 1979 04b0 6B000000 		.4byte	0x6b
 1980 04b4 02       		.uleb128 0x2
 1981 04b5 91       		.byte	0x91
 1982 04b6 77       		.sleb128 -9
 1983 04b7 0E       		.uleb128 0xe
 1984 04b8 A8000000 		.4byte	.LASF58
 1985 04bc 01       		.byte	0x1
 1986 04bd D005     		.2byte	0x5d0
 1987 04bf 6B000000 		.4byte	0x6b
 1988 04c3 05       		.uleb128 0x5
 1989 04c4 03       		.byte	0x3
 1990 04c5 01000000 		.4byte	txPeriod.4898
 1991 04c9 00       		.byte	0
 1992 04ca 00       		.byte	0
 1993 04cb 0B       		.uleb128 0xb
 1994 04cc AF010000 		.4byte	.LASF59
 1995 04d0 01       		.byte	0x1
 1996 04d1 2406     		.2byte	0x624
 1997 04d3 00000000 		.4byte	.LFB27
 1998 04d7 12000000 		.4byte	.LFE27-.LFB27
 1999 04db 01       		.uleb128 0x1
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 64


 2000 04dc 9C       		.byte	0x9c
 2001 04dd F1040000 		.4byte	0x4f1
 2002 04e1 0C       		.uleb128 0xc
 2003 04e2 E3000000 		.4byte	.LASF38
 2004 04e6 01       		.byte	0x1
 2005 04e7 2406     		.2byte	0x624
 2006 04e9 6B000000 		.4byte	0x6b
 2007 04ed 02       		.uleb128 0x2
 2008 04ee 91       		.byte	0x91
 2009 04ef 77       		.sleb128 -9
 2010 04f0 00       		.byte	0
 2011 04f1 14       		.uleb128 0x14
 2012 04f2 FA020000 		.4byte	.LASF63
 2013 04f6 01       		.byte	0x1
 2014 04f7 1B       		.byte	0x1b
 2015 04f8 6B000000 		.4byte	0x6b
 2016 04fc 05       		.uleb128 0x5
 2017 04fd 03       		.byte	0x3
 2018 04fe 00000000 		.4byte	UART_1_initVar
 2019 0502 00       		.byte	0
 2020              		.section	.debug_abbrev,"",%progbits
 2021              	.Ldebug_abbrev0:
 2022 0000 01       		.uleb128 0x1
 2023 0001 11       		.uleb128 0x11
 2024 0002 01       		.byte	0x1
 2025 0003 25       		.uleb128 0x25
 2026 0004 0E       		.uleb128 0xe
 2027 0005 13       		.uleb128 0x13
 2028 0006 0B       		.uleb128 0xb
 2029 0007 03       		.uleb128 0x3
 2030 0008 0E       		.uleb128 0xe
 2031 0009 1B       		.uleb128 0x1b
 2032 000a 0E       		.uleb128 0xe
 2033 000b 55       		.uleb128 0x55
 2034 000c 17       		.uleb128 0x17
 2035 000d 11       		.uleb128 0x11
 2036 000e 01       		.uleb128 0x1
 2037 000f 10       		.uleb128 0x10
 2038 0010 17       		.uleb128 0x17
 2039 0011 00       		.byte	0
 2040 0012 00       		.byte	0
 2041 0013 02       		.uleb128 0x2
 2042 0014 24       		.uleb128 0x24
 2043 0015 00       		.byte	0
 2044 0016 0B       		.uleb128 0xb
 2045 0017 0B       		.uleb128 0xb
 2046 0018 3E       		.uleb128 0x3e
 2047 0019 0B       		.uleb128 0xb
 2048 001a 03       		.uleb128 0x3
 2049 001b 0E       		.uleb128 0xe
 2050 001c 00       		.byte	0
 2051 001d 00       		.byte	0
 2052 001e 03       		.uleb128 0x3
 2053 001f 24       		.uleb128 0x24
 2054 0020 00       		.byte	0
 2055 0021 0B       		.uleb128 0xb
 2056 0022 0B       		.uleb128 0xb
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 65


 2057 0023 3E       		.uleb128 0x3e
 2058 0024 0B       		.uleb128 0xb
 2059 0025 03       		.uleb128 0x3
 2060 0026 08       		.uleb128 0x8
 2061 0027 00       		.byte	0
 2062 0028 00       		.byte	0
 2063 0029 04       		.uleb128 0x4
 2064 002a 16       		.uleb128 0x16
 2065 002b 00       		.byte	0
 2066 002c 03       		.uleb128 0x3
 2067 002d 0E       		.uleb128 0xe
 2068 002e 3A       		.uleb128 0x3a
 2069 002f 0B       		.uleb128 0xb
 2070 0030 3B       		.uleb128 0x3b
 2071 0031 05       		.uleb128 0x5
 2072 0032 49       		.uleb128 0x49
 2073 0033 13       		.uleb128 0x13
 2074 0034 00       		.byte	0
 2075 0035 00       		.byte	0
 2076 0036 05       		.uleb128 0x5
 2077 0037 35       		.uleb128 0x35
 2078 0038 00       		.byte	0
 2079 0039 49       		.uleb128 0x49
 2080 003a 13       		.uleb128 0x13
 2081 003b 00       		.byte	0
 2082 003c 00       		.byte	0
 2083 003d 06       		.uleb128 0x6
 2084 003e 2E       		.uleb128 0x2e
 2085 003f 00       		.byte	0
 2086 0040 3F       		.uleb128 0x3f
 2087 0041 19       		.uleb128 0x19
 2088 0042 03       		.uleb128 0x3
 2089 0043 0E       		.uleb128 0xe
 2090 0044 3A       		.uleb128 0x3a
 2091 0045 0B       		.uleb128 0xb
 2092 0046 3B       		.uleb128 0x3b
 2093 0047 0B       		.uleb128 0xb
 2094 0048 27       		.uleb128 0x27
 2095 0049 19       		.uleb128 0x19
 2096 004a 11       		.uleb128 0x11
 2097 004b 01       		.uleb128 0x1
 2098 004c 12       		.uleb128 0x12
 2099 004d 06       		.uleb128 0x6
 2100 004e 40       		.uleb128 0x40
 2101 004f 18       		.uleb128 0x18
 2102 0050 9642     		.uleb128 0x2116
 2103 0052 19       		.uleb128 0x19
 2104 0053 00       		.byte	0
 2105 0054 00       		.byte	0
 2106 0055 07       		.uleb128 0x7
 2107 0056 2E       		.uleb128 0x2e
 2108 0057 00       		.byte	0
 2109 0058 3F       		.uleb128 0x3f
 2110 0059 19       		.uleb128 0x19
 2111 005a 03       		.uleb128 0x3
 2112 005b 0E       		.uleb128 0xe
 2113 005c 3A       		.uleb128 0x3a
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 66


 2114 005d 0B       		.uleb128 0xb
 2115 005e 3B       		.uleb128 0x3b
 2116 005f 0B       		.uleb128 0xb
 2117 0060 27       		.uleb128 0x27
 2118 0061 19       		.uleb128 0x19
 2119 0062 11       		.uleb128 0x11
 2120 0063 01       		.uleb128 0x1
 2121 0064 12       		.uleb128 0x12
 2122 0065 06       		.uleb128 0x6
 2123 0066 40       		.uleb128 0x40
 2124 0067 18       		.uleb128 0x18
 2125 0068 9742     		.uleb128 0x2117
 2126 006a 19       		.uleb128 0x19
 2127 006b 00       		.byte	0
 2128 006c 00       		.byte	0
 2129 006d 08       		.uleb128 0x8
 2130 006e 2E       		.uleb128 0x2e
 2131 006f 01       		.byte	0x1
 2132 0070 3F       		.uleb128 0x3f
 2133 0071 19       		.uleb128 0x19
 2134 0072 03       		.uleb128 0x3
 2135 0073 0E       		.uleb128 0xe
 2136 0074 3A       		.uleb128 0x3a
 2137 0075 0B       		.uleb128 0xb
 2138 0076 3B       		.uleb128 0x3b
 2139 0077 0B       		.uleb128 0xb
 2140 0078 27       		.uleb128 0x27
 2141 0079 19       		.uleb128 0x19
 2142 007a 11       		.uleb128 0x11
 2143 007b 01       		.uleb128 0x1
 2144 007c 12       		.uleb128 0x12
 2145 007d 06       		.uleb128 0x6
 2146 007e 40       		.uleb128 0x40
 2147 007f 18       		.uleb128 0x18
 2148 0080 9642     		.uleb128 0x2116
 2149 0082 19       		.uleb128 0x19
 2150 0083 01       		.uleb128 0x1
 2151 0084 13       		.uleb128 0x13
 2152 0085 00       		.byte	0
 2153 0086 00       		.byte	0
 2154 0087 09       		.uleb128 0x9
 2155 0088 34       		.uleb128 0x34
 2156 0089 00       		.byte	0
 2157 008a 03       		.uleb128 0x3
 2158 008b 0E       		.uleb128 0xe
 2159 008c 3A       		.uleb128 0x3a
 2160 008d 0B       		.uleb128 0xb
 2161 008e 3B       		.uleb128 0x3b
 2162 008f 0B       		.uleb128 0xb
 2163 0090 49       		.uleb128 0x49
 2164 0091 13       		.uleb128 0x13
 2165 0092 02       		.uleb128 0x2
 2166 0093 18       		.uleb128 0x18
 2167 0094 00       		.byte	0
 2168 0095 00       		.byte	0
 2169 0096 0A       		.uleb128 0xa
 2170 0097 2E       		.uleb128 0x2e
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 67


 2171 0098 00       		.byte	0
 2172 0099 3F       		.uleb128 0x3f
 2173 009a 19       		.uleb128 0x19
 2174 009b 03       		.uleb128 0x3
 2175 009c 0E       		.uleb128 0xe
 2176 009d 3A       		.uleb128 0x3a
 2177 009e 0B       		.uleb128 0xb
 2178 009f 3B       		.uleb128 0x3b
 2179 00a0 05       		.uleb128 0x5
 2180 00a1 27       		.uleb128 0x27
 2181 00a2 19       		.uleb128 0x19
 2182 00a3 49       		.uleb128 0x49
 2183 00a4 13       		.uleb128 0x13
 2184 00a5 11       		.uleb128 0x11
 2185 00a6 01       		.uleb128 0x1
 2186 00a7 12       		.uleb128 0x12
 2187 00a8 06       		.uleb128 0x6
 2188 00a9 40       		.uleb128 0x40
 2189 00aa 18       		.uleb128 0x18
 2190 00ab 9742     		.uleb128 0x2117
 2191 00ad 19       		.uleb128 0x19
 2192 00ae 00       		.byte	0
 2193 00af 00       		.byte	0
 2194 00b0 0B       		.uleb128 0xb
 2195 00b1 2E       		.uleb128 0x2e
 2196 00b2 01       		.byte	0x1
 2197 00b3 3F       		.uleb128 0x3f
 2198 00b4 19       		.uleb128 0x19
 2199 00b5 03       		.uleb128 0x3
 2200 00b6 0E       		.uleb128 0xe
 2201 00b7 3A       		.uleb128 0x3a
 2202 00b8 0B       		.uleb128 0xb
 2203 00b9 3B       		.uleb128 0x3b
 2204 00ba 05       		.uleb128 0x5
 2205 00bb 27       		.uleb128 0x27
 2206 00bc 19       		.uleb128 0x19
 2207 00bd 11       		.uleb128 0x11
 2208 00be 01       		.uleb128 0x1
 2209 00bf 12       		.uleb128 0x12
 2210 00c0 06       		.uleb128 0x6
 2211 00c1 40       		.uleb128 0x40
 2212 00c2 18       		.uleb128 0x18
 2213 00c3 9742     		.uleb128 0x2117
 2214 00c5 19       		.uleb128 0x19
 2215 00c6 01       		.uleb128 0x1
 2216 00c7 13       		.uleb128 0x13
 2217 00c8 00       		.byte	0
 2218 00c9 00       		.byte	0
 2219 00ca 0C       		.uleb128 0xc
 2220 00cb 05       		.uleb128 0x5
 2221 00cc 00       		.byte	0
 2222 00cd 03       		.uleb128 0x3
 2223 00ce 0E       		.uleb128 0xe
 2224 00cf 3A       		.uleb128 0x3a
 2225 00d0 0B       		.uleb128 0xb
 2226 00d1 3B       		.uleb128 0x3b
 2227 00d2 05       		.uleb128 0x5
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 68


 2228 00d3 49       		.uleb128 0x49
 2229 00d4 13       		.uleb128 0x13
 2230 00d5 02       		.uleb128 0x2
 2231 00d6 18       		.uleb128 0x18
 2232 00d7 00       		.byte	0
 2233 00d8 00       		.byte	0
 2234 00d9 0D       		.uleb128 0xd
 2235 00da 2E       		.uleb128 0x2e
 2236 00db 01       		.byte	0x1
 2237 00dc 3F       		.uleb128 0x3f
 2238 00dd 19       		.uleb128 0x19
 2239 00de 03       		.uleb128 0x3
 2240 00df 0E       		.uleb128 0xe
 2241 00e0 3A       		.uleb128 0x3a
 2242 00e1 0B       		.uleb128 0xb
 2243 00e2 3B       		.uleb128 0x3b
 2244 00e3 05       		.uleb128 0x5
 2245 00e4 27       		.uleb128 0x27
 2246 00e5 19       		.uleb128 0x19
 2247 00e6 49       		.uleb128 0x49
 2248 00e7 13       		.uleb128 0x13
 2249 00e8 11       		.uleb128 0x11
 2250 00e9 01       		.uleb128 0x1
 2251 00ea 12       		.uleb128 0x12
 2252 00eb 06       		.uleb128 0x6
 2253 00ec 40       		.uleb128 0x40
 2254 00ed 18       		.uleb128 0x18
 2255 00ee 9742     		.uleb128 0x2117
 2256 00f0 19       		.uleb128 0x19
 2257 00f1 01       		.uleb128 0x1
 2258 00f2 13       		.uleb128 0x13
 2259 00f3 00       		.byte	0
 2260 00f4 00       		.byte	0
 2261 00f5 0E       		.uleb128 0xe
 2262 00f6 34       		.uleb128 0x34
 2263 00f7 00       		.byte	0
 2264 00f8 03       		.uleb128 0x3
 2265 00f9 0E       		.uleb128 0xe
 2266 00fa 3A       		.uleb128 0x3a
 2267 00fb 0B       		.uleb128 0xb
 2268 00fc 3B       		.uleb128 0x3b
 2269 00fd 05       		.uleb128 0x5
 2270 00fe 49       		.uleb128 0x49
 2271 00ff 13       		.uleb128 0x13
 2272 0100 02       		.uleb128 0x2
 2273 0101 18       		.uleb128 0x18
 2274 0102 00       		.byte	0
 2275 0103 00       		.byte	0
 2276 0104 0F       		.uleb128 0xf
 2277 0105 2E       		.uleb128 0x2e
 2278 0106 00       		.byte	0
 2279 0107 3F       		.uleb128 0x3f
 2280 0108 19       		.uleb128 0x19
 2281 0109 03       		.uleb128 0x3
 2282 010a 0E       		.uleb128 0xe
 2283 010b 3A       		.uleb128 0x3a
 2284 010c 0B       		.uleb128 0xb
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 69


 2285 010d 3B       		.uleb128 0x3b
 2286 010e 05       		.uleb128 0x5
 2287 010f 27       		.uleb128 0x27
 2288 0110 19       		.uleb128 0x19
 2289 0111 49       		.uleb128 0x49
 2290 0112 13       		.uleb128 0x13
 2291 0113 11       		.uleb128 0x11
 2292 0114 01       		.uleb128 0x1
 2293 0115 12       		.uleb128 0x12
 2294 0116 06       		.uleb128 0x6
 2295 0117 40       		.uleb128 0x40
 2296 0118 18       		.uleb128 0x18
 2297 0119 9642     		.uleb128 0x2116
 2298 011b 19       		.uleb128 0x19
 2299 011c 00       		.byte	0
 2300 011d 00       		.byte	0
 2301 011e 10       		.uleb128 0x10
 2302 011f 2E       		.uleb128 0x2e
 2303 0120 01       		.byte	0x1
 2304 0121 3F       		.uleb128 0x3f
 2305 0122 19       		.uleb128 0x19
 2306 0123 03       		.uleb128 0x3
 2307 0124 0E       		.uleb128 0xe
 2308 0125 3A       		.uleb128 0x3a
 2309 0126 0B       		.uleb128 0xb
 2310 0127 3B       		.uleb128 0x3b
 2311 0128 05       		.uleb128 0x5
 2312 0129 27       		.uleb128 0x27
 2313 012a 19       		.uleb128 0x19
 2314 012b 11       		.uleb128 0x11
 2315 012c 01       		.uleb128 0x1
 2316 012d 12       		.uleb128 0x12
 2317 012e 06       		.uleb128 0x6
 2318 012f 40       		.uleb128 0x40
 2319 0130 18       		.uleb128 0x18
 2320 0131 9642     		.uleb128 0x2116
 2321 0133 19       		.uleb128 0x19
 2322 0134 01       		.uleb128 0x1
 2323 0135 13       		.uleb128 0x13
 2324 0136 00       		.byte	0
 2325 0137 00       		.byte	0
 2326 0138 11       		.uleb128 0x11
 2327 0139 0F       		.uleb128 0xf
 2328 013a 00       		.byte	0
 2329 013b 0B       		.uleb128 0xb
 2330 013c 0B       		.uleb128 0xb
 2331 013d 49       		.uleb128 0x49
 2332 013e 13       		.uleb128 0x13
 2333 013f 00       		.byte	0
 2334 0140 00       		.byte	0
 2335 0141 12       		.uleb128 0x12
 2336 0142 26       		.uleb128 0x26
 2337 0143 00       		.byte	0
 2338 0144 49       		.uleb128 0x49
 2339 0145 13       		.uleb128 0x13
 2340 0146 00       		.byte	0
 2341 0147 00       		.byte	0
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 70


 2342 0148 13       		.uleb128 0x13
 2343 0149 0B       		.uleb128 0xb
 2344 014a 01       		.byte	0x1
 2345 014b 11       		.uleb128 0x11
 2346 014c 01       		.uleb128 0x1
 2347 014d 12       		.uleb128 0x12
 2348 014e 06       		.uleb128 0x6
 2349 014f 00       		.byte	0
 2350 0150 00       		.byte	0
 2351 0151 14       		.uleb128 0x14
 2352 0152 34       		.uleb128 0x34
 2353 0153 00       		.byte	0
 2354 0154 03       		.uleb128 0x3
 2355 0155 0E       		.uleb128 0xe
 2356 0156 3A       		.uleb128 0x3a
 2357 0157 0B       		.uleb128 0xb
 2358 0158 3B       		.uleb128 0x3b
 2359 0159 0B       		.uleb128 0xb
 2360 015a 49       		.uleb128 0x49
 2361 015b 13       		.uleb128 0x13
 2362 015c 3F       		.uleb128 0x3f
 2363 015d 19       		.uleb128 0x19
 2364 015e 02       		.uleb128 0x2
 2365 015f 18       		.uleb128 0x18
 2366 0160 00       		.byte	0
 2367 0161 00       		.byte	0
 2368 0162 00       		.byte	0
 2369              		.section	.debug_aranges,"",%progbits
 2370 0000 EC000000 		.4byte	0xec
 2371 0004 0200     		.2byte	0x2
 2372 0006 00000000 		.4byte	.Ldebug_info0
 2373 000a 04       		.byte	0x4
 2374 000b 00       		.byte	0
 2375 000c 0000     		.2byte	0
 2376 000e 0000     		.2byte	0
 2377 0010 00000000 		.4byte	.LFB1
 2378 0014 24000000 		.4byte	.LFE1-.LFB1
 2379 0018 00000000 		.4byte	.LFB2
 2380 001c 3C000000 		.4byte	.LFE2-.LFB2
 2381 0020 00000000 		.4byte	.LFB3
 2382 0024 64000000 		.4byte	.LFE3-.LFB3
 2383 0028 00000000 		.4byte	.LFB4
 2384 002c 60000000 		.4byte	.LFE4-.LFB4
 2385 0030 00000000 		.4byte	.LFB5
 2386 0034 0C000000 		.4byte	.LFE5-.LFB5
 2387 0038 00000000 		.4byte	.LFB6
 2388 003c 12000000 		.4byte	.LFE6-.LFB6
 2389 0040 00000000 		.4byte	.LFB7
 2390 0044 20000000 		.4byte	.LFE7-.LFB7
 2391 0048 00000000 		.4byte	.LFB8
 2392 004c 20000000 		.4byte	.LFE8-.LFB8
 2393 0050 00000000 		.4byte	.LFB9
 2394 0054 24000000 		.4byte	.LFE9-.LFB9
 2395 0058 00000000 		.4byte	.LFB10
 2396 005c 4C000000 		.4byte	.LFE10-.LFB10
 2397 0060 00000000 		.4byte	.LFB11
 2398 0064 24000000 		.4byte	.LFE11-.LFB11
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 71


 2399 0068 00000000 		.4byte	.LFB12
 2400 006c 30000000 		.4byte	.LFE12-.LFB12
 2401 0070 00000000 		.4byte	.LFB13
 2402 0074 44000000 		.4byte	.LFE13-.LFB13
 2403 0078 00000000 		.4byte	.LFB14
 2404 007c 12000000 		.4byte	.LFE14-.LFB14
 2405 0080 00000000 		.4byte	.LFB15
 2406 0084 20000000 		.4byte	.LFE15-.LFB15
 2407 0088 00000000 		.4byte	.LFB16
 2408 008c 20000000 		.4byte	.LFE16-.LFB16
 2409 0090 00000000 		.4byte	.LFB17
 2410 0094 20000000 		.4byte	.LFE17-.LFB17
 2411 0098 00000000 		.4byte	.LFB18
 2412 009c 2C000000 		.4byte	.LFE18-.LFB18
 2413 00a0 00000000 		.4byte	.LFB19
 2414 00a4 14000000 		.4byte	.LFE19-.LFB19
 2415 00a8 00000000 		.4byte	.LFB20
 2416 00ac 34000000 		.4byte	.LFE20-.LFB20
 2417 00b0 00000000 		.4byte	.LFB21
 2418 00b4 54000000 		.4byte	.LFE21-.LFB21
 2419 00b8 00000000 		.4byte	.LFB22
 2420 00bc 58000000 		.4byte	.LFE22-.LFB22
 2421 00c0 00000000 		.4byte	.LFB23
 2422 00c4 34000000 		.4byte	.LFE23-.LFB23
 2423 00c8 00000000 		.4byte	.LFB24
 2424 00cc 48000000 		.4byte	.LFE24-.LFB24
 2425 00d0 00000000 		.4byte	.LFB25
 2426 00d4 44000000 		.4byte	.LFE25-.LFB25
 2427 00d8 00000000 		.4byte	.LFB26
 2428 00dc B8000000 		.4byte	.LFE26-.LFB26
 2429 00e0 00000000 		.4byte	.LFB27
 2430 00e4 12000000 		.4byte	.LFE27-.LFB27
 2431 00e8 00000000 		.4byte	0
 2432 00ec 00000000 		.4byte	0
 2433              		.section	.debug_ranges,"",%progbits
 2434              	.Ldebug_ranges0:
 2435 0000 00000000 		.4byte	.LFB1
 2436 0004 24000000 		.4byte	.LFE1
 2437 0008 00000000 		.4byte	.LFB2
 2438 000c 3C000000 		.4byte	.LFE2
 2439 0010 00000000 		.4byte	.LFB3
 2440 0014 64000000 		.4byte	.LFE3
 2441 0018 00000000 		.4byte	.LFB4
 2442 001c 60000000 		.4byte	.LFE4
 2443 0020 00000000 		.4byte	.LFB5
 2444 0024 0C000000 		.4byte	.LFE5
 2445 0028 00000000 		.4byte	.LFB6
 2446 002c 12000000 		.4byte	.LFE6
 2447 0030 00000000 		.4byte	.LFB7
 2448 0034 20000000 		.4byte	.LFE7
 2449 0038 00000000 		.4byte	.LFB8
 2450 003c 20000000 		.4byte	.LFE8
 2451 0040 00000000 		.4byte	.LFB9
 2452 0044 24000000 		.4byte	.LFE9
 2453 0048 00000000 		.4byte	.LFB10
 2454 004c 4C000000 		.4byte	.LFE10
 2455 0050 00000000 		.4byte	.LFB11
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 72


 2456 0054 24000000 		.4byte	.LFE11
 2457 0058 00000000 		.4byte	.LFB12
 2458 005c 30000000 		.4byte	.LFE12
 2459 0060 00000000 		.4byte	.LFB13
 2460 0064 44000000 		.4byte	.LFE13
 2461 0068 00000000 		.4byte	.LFB14
 2462 006c 12000000 		.4byte	.LFE14
 2463 0070 00000000 		.4byte	.LFB15
 2464 0074 20000000 		.4byte	.LFE15
 2465 0078 00000000 		.4byte	.LFB16
 2466 007c 20000000 		.4byte	.LFE16
 2467 0080 00000000 		.4byte	.LFB17
 2468 0084 20000000 		.4byte	.LFE17
 2469 0088 00000000 		.4byte	.LFB18
 2470 008c 2C000000 		.4byte	.LFE18
 2471 0090 00000000 		.4byte	.LFB19
 2472 0094 14000000 		.4byte	.LFE19
 2473 0098 00000000 		.4byte	.LFB20
 2474 009c 34000000 		.4byte	.LFE20
 2475 00a0 00000000 		.4byte	.LFB21
 2476 00a4 54000000 		.4byte	.LFE21
 2477 00a8 00000000 		.4byte	.LFB22
 2478 00ac 58000000 		.4byte	.LFE22
 2479 00b0 00000000 		.4byte	.LFB23
 2480 00b4 34000000 		.4byte	.LFE23
 2481 00b8 00000000 		.4byte	.LFB24
 2482 00bc 48000000 		.4byte	.LFE24
 2483 00c0 00000000 		.4byte	.LFB25
 2484 00c4 44000000 		.4byte	.LFE25
 2485 00c8 00000000 		.4byte	.LFB26
 2486 00cc B8000000 		.4byte	.LFE26
 2487 00d0 00000000 		.4byte	.LFB27
 2488 00d4 12000000 		.4byte	.LFE27
 2489 00d8 00000000 		.4byte	0
 2490 00dc 00000000 		.4byte	0
 2491              		.section	.debug_line,"",%progbits
 2492              	.Ldebug_line0:
 2493 0000 E0020000 		.section	.debug_str,"MS",%progbits,1
 2493      02004300 
 2493      00000201 
 2493      FB0E0D00 
 2493      01010101 
 2494              	.LASF10:
 2495 0000 75696E74 		.ascii	"uint16\000"
 2495      313600
 2496              	.LASF54:
 2497 0007 55415254 		.ascii	"UART_1_ClearTxBuffer\000"
 2497      5F315F43 
 2497      6C656172 
 2497      54784275 
 2497      66666572 
 2498              	.LASF44:
 2499 001c 74784461 		.ascii	"txDataByte\000"
 2499      74614279 
 2499      746500
 2500              	.LASF46:
 2501 0027 55415254 		.ascii	"UART_1_PutChar\000"
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 73


 2501      5F315F50 
 2501      75744368 
 2501      617200
 2502              	.LASF48:
 2503 0036 73747269 		.ascii	"string\000"
 2503      6E6700
 2504              	.LASF55:
 2505 003d 55415254 		.ascii	"UART_1_SendBreak\000"
 2505      5F315F53 
 2505      656E6442 
 2505      7265616B 
 2505      00
 2506              	.LASF27:
 2507 004e 55415254 		.ascii	"UART_1_ReadRxData\000"
 2507      5F315F52 
 2507      65616452 
 2507      78446174 
 2507      6100
 2508              	.LASF7:
 2509 0060 6C6F6E67 		.ascii	"long long unsigned int\000"
 2509      206C6F6E 
 2509      6720756E 
 2509      7369676E 
 2509      65642069 
 2510              	.LASF53:
 2511 0077 55415254 		.ascii	"UART_1_GetTxBufferSize\000"
 2511      5F315F47 
 2511      65745478 
 2511      42756666 
 2511      65725369 
 2512              	.LASF6:
 2513 008e 6C6F6E67 		.ascii	"long long int\000"
 2513      206C6F6E 
 2513      6720696E 
 2513      7400
 2514              	.LASF0:
 2515 009c 7369676E 		.ascii	"signed char\000"
 2515      65642063 
 2515      68617200 
 2516              	.LASF58:
 2517 00a8 74785065 		.ascii	"txPeriod\000"
 2517      72696F64 
 2517      00
 2518              	.LASF52:
 2519 00b1 55415254 		.ascii	"UART_1_PutCRLF\000"
 2519      5F315F50 
 2519      75744352 
 2519      4C4600
 2520              	.LASF4:
 2521 00c0 6C6F6E67 		.ascii	"long int\000"
 2521      20696E74 
 2521      00
 2522              	.LASF17:
 2523 00c9 55415254 		.ascii	"UART_1_Start\000"
 2523      5F315F53 
 2523      74617274 
 2523      00
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 74


 2524              	.LASF9:
 2525 00d6 75696E74 		.ascii	"uint8\000"
 2525      3800
 2526              	.LASF12:
 2527 00dc 646F7562 		.ascii	"double\000"
 2527      6C6500
 2528              	.LASF38:
 2529 00e3 61646472 		.ascii	"addressMode\000"
 2529      6573734D 
 2529      6F646500 
 2530              	.LASF28:
 2531 00ef 55415254 		.ascii	"UART_1_ReadRxStatus\000"
 2531      5F315F52 
 2531      65616452 
 2531      78537461 
 2531      74757300 
 2532              	.LASF24:
 2533 0103 636F6E74 		.ascii	"control\000"
 2533      726F6C00 
 2534              	.LASF23:
 2535 010b 55415254 		.ascii	"UART_1_SetRxInterruptMode\000"
 2535      5F315F53 
 2535      65745278 
 2535      496E7465 
 2535      72727570 
 2536              	.LASF61:
 2537 0125 47656E65 		.ascii	"Generated_Source\\PSoC4\\UART_1.c\000"
 2537      72617465 
 2537      645F536F 
 2537      75726365 
 2537      5C50536F 
 2538              	.LASF56:
 2539 0145 7265744D 		.ascii	"retMode\000"
 2539      6F646500 
 2540              	.LASF8:
 2541 014d 756E7369 		.ascii	"unsigned int\000"
 2541      676E6564 
 2541      20696E74 
 2541      00
 2542              	.LASF45:
 2543 015a 55415254 		.ascii	"UART_1_ReadTxStatus\000"
 2543      5F315F52 
 2543      65616454 
 2543      78537461 
 2543      74757300 
 2544              	.LASF5:
 2545 016e 6C6F6E67 		.ascii	"long unsigned int\000"
 2545      20756E73 
 2545      69676E65 
 2545      6420696E 
 2545      7400
 2546              	.LASF35:
 2547 0180 73697A65 		.ascii	"size\000"
 2547      00
 2548              	.LASF3:
 2549 0185 73686F72 		.ascii	"short unsigned int\000"
 2549      7420756E 
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 75


 2549      7369676E 
 2549      65642069 
 2549      6E7400
 2550              	.LASF19:
 2551 0198 55415254 		.ascii	"UART_1_Enable\000"
 2551      5F315F45 
 2551      6E61626C 
 2551      6500
 2552              	.LASF49:
 2553 01a6 62756649 		.ascii	"bufIndex\000"
 2553      6E646578 
 2553      00
 2554              	.LASF59:
 2555 01af 55415254 		.ascii	"UART_1_SetTxAddressMode\000"
 2555      5F315F53 
 2555      65745478 
 2555      41646472 
 2555      6573734D 
 2556              	.LASF25:
 2557 01c7 696E7453 		.ascii	"intSrc\000"
 2557      726300
 2558              	.LASF32:
 2559 01ce 55415254 		.ascii	"UART_1_ReadControlRegister\000"
 2559      5F315F52 
 2559      65616443 
 2559      6F6E7472 
 2559      6F6C5265 
 2560              	.LASF20:
 2561 01e9 55415254 		.ascii	"UART_1_Stop\000"
 2561      5F315F53 
 2561      746F7000 
 2562              	.LASF33:
 2563 01f5 55415254 		.ascii	"UART_1_GetByte\000"
 2563      5F315F47 
 2563      65744279 
 2563      746500
 2564              	.LASF43:
 2565 0204 55415254 		.ascii	"UART_1_WriteTxData\000"
 2565      5F315F57 
 2565      72697465 
 2565      54784461 
 2565      746100
 2566              	.LASF57:
 2567 0217 746D7053 		.ascii	"tmpStat\000"
 2567      74617400 
 2568              	.LASF16:
 2569 021f 73697A65 		.ascii	"sizetype\000"
 2569      74797065 
 2569      00
 2570              	.LASF39:
 2571 0228 55415254 		.ascii	"UART_1_SetRxAddress1\000"
 2571      5F315F53 
 2571      65745278 
 2571      41646472 
 2571      65737331 
 2572              	.LASF41:
 2573 023d 55415254 		.ascii	"UART_1_SetRxAddress2\000"
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 76


 2573      5F315F53 
 2573      65745278 
 2573      41646472 
 2573      65737332 
 2574              	.LASF40:
 2575 0252 61646472 		.ascii	"address\000"
 2575      65737300 
 2576              	.LASF31:
 2577 025a 72785374 		.ascii	"rxStatus\000"
 2577      61747573 
 2577      00
 2578              	.LASF42:
 2579 0263 55415254 		.ascii	"UART_1_SetTxInterruptMode\000"
 2579      5F315F53 
 2579      65745478 
 2579      496E7465 
 2579      72727570 
 2580              	.LASF11:
 2581 027d 666C6F61 		.ascii	"float\000"
 2581      7400
 2582              	.LASF47:
 2583 0283 55415254 		.ascii	"UART_1_PutString\000"
 2583      5F315F50 
 2583      75745374 
 2583      72696E67 
 2583      00
 2584              	.LASF36:
 2585 0294 55415254 		.ascii	"UART_1_ClearRxBuffer\000"
 2585      5F315F43 
 2585      6C656172 
 2585      52784275 
 2585      66666572 
 2586              	.LASF37:
 2587 02a9 55415254 		.ascii	"UART_1_SetRxAddressMode\000"
 2587      5F315F53 
 2587      65745278 
 2587      41646472 
 2587      6573734D 
 2588              	.LASF15:
 2589 02c1 72656738 		.ascii	"reg8\000"
 2589      00
 2590              	.LASF1:
 2591 02c6 756E7369 		.ascii	"unsigned char\000"
 2591      676E6564 
 2591      20636861 
 2591      7200
 2592              	.LASF2:
 2593 02d4 73686F72 		.ascii	"short int\000"
 2593      7420696E 
 2593      7400
 2594              	.LASF22:
 2595 02de 55415254 		.ascii	"UART_1_WriteControlRegister\000"
 2595      5F315F57 
 2595      72697465 
 2595      436F6E74 
 2595      726F6C52 
 2596              	.LASF63:
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 77


 2597 02fa 55415254 		.ascii	"UART_1_initVar\000"
 2597      5F315F69 
 2597      6E697456 
 2597      617200
 2598              	.LASF51:
 2599 0309 62797465 		.ascii	"byteCount\000"
 2599      436F756E 
 2599      7400
 2600              	.LASF62:
 2601 0313 433A5C55 		.ascii	"C:\\Users\\glenn\\OneDrive\\PSOC\\moisture_sensor_4"
 2601      73657273 
 2601      5C676C65 
 2601      6E6E5C4F 
 2601      6E654472 
 2602 0341 6D5C4D6F 		.ascii	"m\\Moisture_Sensor\\Moisture_Sensor.cydsn\000"
 2602      69737475 
 2602      72655F53 
 2602      656E736F 
 2602      725C4D6F 
 2603              	.LASF34:
 2604 0369 55415254 		.ascii	"UART_1_GetRxBufferSize\000"
 2604      5F315F47 
 2604      65745278 
 2604      42756666 
 2604      65725369 
 2605              	.LASF26:
 2606 0380 72784461 		.ascii	"rxData\000"
 2606      746100
 2607              	.LASF14:
 2608 0387 63686172 		.ascii	"char\000"
 2608      00
 2609              	.LASF13:
 2610 038c 63686172 		.ascii	"char8\000"
 2610      3800
 2611              	.LASF18:
 2612 0392 55415254 		.ascii	"UART_1_Init\000"
 2612      5F315F49 
 2612      6E697400 
 2613              	.LASF21:
 2614 039e 656E6162 		.ascii	"enableInterrupts\000"
 2614      6C65496E 
 2614      74657272 
 2614      75707473 
 2614      00
 2615              	.LASF29:
 2616 03af 73746174 		.ascii	"status\000"
 2616      757300
 2617              	.LASF60:
 2618 03b6 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 2618      4320342E 
 2618      392E3320 
 2618      32303135 
 2618      30333033 
 2619 03e9 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m0 -mthumb -g -O"
 2619      20726576 
 2619      6973696F 
 2619      6E203232 
ARM GAS  C:\Users\glenn\AppData\Local\Temp\ccVuL4sl.s 			page 78


 2619      31323230 
 2620 041c 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 2620      66756E63 
 2620      74696F6E 
 2620      2D736563 
 2620      74696F6E 
 2621              	.LASF30:
 2622 0444 55415254 		.ascii	"UART_1_GetChar\000"
 2622      5F315F47 
 2622      65744368 
 2622      617200
 2623              	.LASF50:
 2624 0453 55415254 		.ascii	"UART_1_PutArray\000"
 2624      5F315F50 
 2624      75744172 
 2624      72617900 
 2625              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
